/* automatically generated by rust-bindgen 0.66.1 */

pub type std_true_type = u8;
pub type std_false_type = u8;
pub type std_underlying_type_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_value_type = u8;
pub type std_allocator_size_type = u64;
pub type std_allocator_difference_type = u64;
pub type std_allocator_pointer = u8;
pub type std_allocator_const_pointer = u8;
pub type std_allocator_reference = u8;
pub type std_allocator_const_reference = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = u8;
pub type std_allocator_propagate_on_container_move_assignment = u8;
pub type std_allocator_is_always_equal = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator {
    pub _address: u8,
}
pub type std_reverse_iterator___traits_type = u8;
pub type std_reverse_iterator_iterator_type = u8;
pub type std_reverse_iterator_pointer = u8;
pub type std_reverse_iterator_difference_type = u8;
pub type std_reverse_iterator_reference = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_default_delete {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unique_ptr {
    pub _address: u8,
}
pub type std_unique_ptr__DeleterConstraint = u8;
pub type std_unique_ptr_pointer = u8;
pub type std_unique_ptr_element_type = u8;
pub type std_unique_ptr_deleter_type = u8;
pub type std_unique_ptr___safe_conversion_up = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_shared_ptr {
    pub _address: u8,
}
pub type std_shared_ptr__Constructible = u8;
pub type std_shared_ptr__Assignable = u8;
pub type std_shared_ptr_element_type = u8;
pub type std_shared_ptr_weak_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_vector {
    pub _address: u8,
}
pub type std_vector__Base = u8;
pub type std_vector__Tp_alloc_type = u8;
pub type std_vector__Alloc_traits = u8;
pub type std_vector_value_type = u8;
pub type std_vector_pointer = u8;
pub type std_vector_const_pointer = u8;
pub type std_vector_reference = u8;
pub type std_vector_const_reference = u8;
pub type std_vector_iterator = u8;
pub type std_vector_const_iterator = u8;
pub type std_vector_const_reverse_iterator = u8;
pub type std_vector_reverse_iterator = u8;
pub type std_vector_size_type = u64;
pub type std_vector_difference_type = u64;
pub type std_vector_allocator_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_vector__Temporary_value {
    pub _address: u8,
}
#[repr(C)]
#[repr(align(1))]
#[derive(Copy, Clone)]
pub union std_vector__Temporary_value__Storage {
    pub _bindgen_opaque_blob: u8,
}
pub type real = f32;
pub type rvec = [real; 3usize];
pub type matrix = [[real; 3usize]; 3usize];
pub type tensor = [[real; 3usize]; 3usize];
pub type ivec = [::std::os::raw::c_int; 3usize];
#[doc = " \\brief\n C++ class for 3D vectors.\n\n \\tparam ValueType  Type\n\n This class provides a C++ version of rvec/dvec/ivec that can be put into STL\n containers etc.  It is more or less a drop-in replacement for `rvec` and\n friends: it can be used in most contexts that accept the equivalent C type.\n However, there is one case where explicit conversion is necessary:\n  - An array of these objects needs to be converted with as_vec_array() (or\n    convenience methods like as_rvec_array()).\n\n For the array conversion to work, the compiler should not add any extra\n alignment/padding in the layout of this class;  that this actually works as\n intended is tested in the unit tests.\n\n \\inpublicapi"]
#[repr(C)]
#[derive(Debug)]
pub struct gmx_BasicVector<ValueType> {
    pub x_: gmx_BasicVector_RawArray<ValueType>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<ValueType>>,
}
#[doc = "! Underlying raw C array type (rvec/dvec/ivec)."]
pub type gmx_BasicVector_RawArray<ValueType> = [ValueType; 3usize];
#[doc = "! Shorthand for C++ `rvec`-equivalent type."]
pub type gmx_RVec = gmx_BasicVector<real>;
#[doc = " \\brief Integer type for indexing into arrays or vectors\n\n Same as ptrdiff_t."]
pub type gmx_index = isize;
#[doc = "! Convenience alias"]
pub type gmx_EnumerationIterator_IntegerType = u8;
#[doc = "! Convenience alias."]
pub type gmx_EnumerationWrapper_IteratorType = u8;
#[doc = "! Convenience alias"]
pub type gmx_EnumerationWrapper_value_type<EnumType> = EnumType;
#[doc = "! Convenience alias"]
pub type gmx_EnumerationArray_EnumerationWrapperType = u8;
#[doc = "! Convenience alias"]
pub type gmx_EnumerationArray_value_type<DataType> = DataType;
#[doc = "@{*/\n//! Range iterators (unchecked)"]
pub type gmx_EnumerationArray_iterator<DataType> = *mut DataType;
pub type gmx_EnumerationArray_const_iterator<DataType> = *const DataType;
pub type gmx_EnumerationArray_reverse_iterator = u8;
pub type gmx_EnumerationArray_const_reverse_iterator = u8;
#[doc = "@{*/\n//! Pointers (unchecked)"]
pub type gmx_EnumerationArray_pointer<DataType> = *mut DataType;
pub type gmx_EnumerationArray_const_pointer<DataType> = *const DataType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gmx_AwhParams {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gmx_KeyValueTreeObject {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gmx_MtsLevel {
    _unused: [u8; 0],
}
#[doc = " \\libinternal \\brief Policy-based memory allocator.\n\n  \\tparam T                 Type of objects to allocate\n  \\tparam AllocationPolicy  Policy of (matching) allocation and deallocation functions.\n\n This class can be used for the optional allocator template\n parameter in standard library containers. It must be configured\n with both the type of object to allocate, and an AllocationPolicy\n which effectively wraps a matching pair of malloc and free\n functions. This permits implementing a family of related allocators\n e.g. with SIMD alignment, GPU host-side page locking, or perhaps\n both, in a way that preserves a common programming interface and\n duplicates minimal code.\n\n AllocationPolicy is used as a base class, so that if\n AllocationPolicy is stateless, then the empty base optimization\n will ensure that Allocation is also stateless, and objects made\n with the Allocator will incur no size penalty. (Embedding an\n AllocationPolicy object incurs a size penalty always, even if the\n object is empty.) Normally a stateless allocator will be used.\n\n However, an AllocationPolicy with state might be desirable for\n simplifying writing code that needs to allocate suitably for a\n transfer to a GPU. That code needs to specify an Allocator that can\n do the right job, which can be stateless. However, if we have code\n that will not know until run time whether a GPU transfer will\n occur, then the allocator needs to be aware of the state.  That\n will increase the size of a container that uses the stateful\n allocator.\n\n \\throws std::bad_alloc Instead of a GROMACS exception object, we\n throw the standard one on allocation failures to make it as\n compatible as possible with the errors expected by code using the\n standard library containers.\n\n \\inlibraryapi\n \\ingroup module_utility"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gmx_Allocator<AllocationPolicy> {
    pub _base: AllocationPolicy,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<AllocationPolicy>>,
}
pub type gmx_Allocator_value_type<T> = T;
#[doc = " \\brief PaddedVector is a container of elements in contiguous\n storage that allocates extra memory for safe SIMD-style loads for\n operations used in GROMACS.\n\n \\tparam T the type of objects within the container\n \\tparam Allocator the allocator used. Can be any standard-compliant\n allocator, such gmx::Allocator used for alignment and/or pinning.\n\n The interface resembles std::vector. However, access\n intended to include padded elements must be via ArrayRef objects\n explicitly created to view those elements. Most other aspects of\n this vector refer to the unpadded view, e.g. iterators, data(),\n size().\n\n The underlying storage is allocated with extra elements, properly\n initialized, that ensure that any operations accessing the any\n non-additional element that operate on memory equivalent to a full\n SIMD lane do so on allocated memory that has been initialized, so\n that memory traps will not occur, and arithmetic operations will\n not cause e.g. floating-point exceptions so long as the values in\n the padded elements are properly managed.\n\n Proper initialization is tricker than it would first appear, since\n we intend this container to be used with scalar and class types\n (e.g. RVec). Resize and construction operations use \"default\n insertion\" which leads to zero initialization for the former, and\n calling the default constructor for the latter. BasicVector has a\n default constructor that leaves the elements uninitialized, which\n is particularly risky for elements only present as padding. Thus\n the implementation specifically initializes the padded elements to\n zero, which makes no difference to the scalar template\n instantiations, and makes the BasicVector ones safer to use.\n\n Because the allocator can be configured, the memory allocation can\n have other attributes such as SIMD alignment or being pinned to\n physical memory for efficient transfers. The default allocator\n ensures alignment, but std::allocator also works."]
#[repr(C)]
#[derive(Debug)]
pub struct gmx_PaddedVector {
    pub storage_: gmx_PaddedVector_storage_type,
    pub unpaddedEnd_: gmx_PaddedVector_iterator,
}
#[doc = "! Standard helper types\n! \\{"]
pub type gmx_PaddedVector_value_type<T> = T;
pub type gmx_PaddedVector_allocator_type<Allocator> = Allocator;
pub type gmx_PaddedVector_size_type = gmx_index;
pub type gmx_PaddedVector_reference<T> = *mut gmx_PaddedVector_value_type<T>;
pub type gmx_PaddedVector_const_reference<T> = *const gmx_PaddedVector_value_type<T>;
pub type gmx_PaddedVector_storage_type = u8;
pub type gmx_PaddedVector_pointer = gmx_PaddedVector_storage_type;
pub type gmx_PaddedVector_const_pointer = gmx_PaddedVector_storage_type;
pub type gmx_PaddedVector_iterator = gmx_PaddedVector_storage_type;
pub type gmx_PaddedVector_const_iterator = gmx_PaddedVector_storage_type;
pub type gmx_PaddedVector_difference_type = gmx_PaddedVector_storage_type;
pub const gmx_PinningPolicy_CannotBePinned: gmx_PinningPolicy = 0;
pub const gmx_PinningPolicy_PinnedIfSupported: gmx_PinningPolicy = 1;
#[doc = " \\brief Helper enum for pinning policy of the allocation of\n HostAllocationPolicy.\n\n For an efficient non-blocking transfer (e.g. to a GPU), the memory\n pages for a buffer need to be pinned to a physical page. Aligning\n such buffers to a physical page should miminize the number of pages\n that need to be pinned. However, some buffers that may be used for\n such transfers may also be used in either GROMACS builds or run\n paths that cannot use such a device, so the policy can be\n configured so that the resource consumption is no higher than\n required for correct, efficient operation in all cases."]
pub type gmx_PinningPolicy = ::std::os::raw::c_int;
#[doc = "! Forward declaration of host allocation policy class."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gmx_HostAllocationPolicy {
    #[doc = "! Pinning policy"]
    pub pinningPolicy_: gmx_PinningPolicy,
}
#[doc = "! Don't propagate for copy"]
pub type gmx_HostAllocationPolicy_propagate_on_container_copy_assignment = std_false_type;
#[doc = "! Propagate for move"]
pub type gmx_HostAllocationPolicy_propagate_on_container_move_assignment = std_true_type;
#[doc = "! Propagate for move"]
pub type gmx_HostAllocationPolicy_propagate_on_container_swap = std_true_type;
extern "C" {
    #[doc = " \\brief Return the alignment size currently used by the active pinning policy."]
    #[link_name = "\u{1}_ZNK3gmx20HostAllocationPolicy9alignmentEv"]
    pub fn gmx_HostAllocationPolicy_alignment(this: *const gmx_HostAllocationPolicy) -> usize;
}
extern "C" {
    #[doc = " \\brief Allocate and perhaps pin page-aligned memory suitable for\n e.g. GPU transfers.\n\n Before attempting to allocate, unpin() is called. After a\n successful allocation, pin() is called. (Whether these do\n things depends on the PinningPolicy that is in effect.)\n\n  \\param bytes Amount of memory (bytes) to allocate. It is valid to ask for\n               0 bytes, which will return a non-null pointer that is properly\n               aligned and padded (but that you should not use).\n\n  \\return Valid pointer if the allocation+optional pinning worked, otherwise nullptr.\n\n  \\note Memory allocated with this routine must be released\n        with gmx::HostAllocationPolicy::free(), and\n        absolutely not the system free().\n\n Does not throw."]
    #[link_name = "\u{1}_ZNK3gmx20HostAllocationPolicy6mallocEm"]
    pub fn gmx_HostAllocationPolicy_malloc(
        this: *const gmx_HostAllocationPolicy,
        bytes: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " \\brief Free the memory, after unpinning (if appropriate).\n\n  \\param buffer  Memory pointer previously returned from gmx::HostAllocationPolicy::malloc()\n\n  \\note This routine should only be called with pointers\n        obtained from gmx:HostAllocationPolicy::malloc(),\n        and absolutely not any pointers obtained the system\n        malloc().\n\n Does not throw."]
    #[link_name = "\u{1}_ZNK3gmx20HostAllocationPolicy4freeEPv"]
    pub fn gmx_HostAllocationPolicy_free(
        this: *const gmx_HostAllocationPolicy,
        buffer: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "! Constructor"]
    #[link_name = "\u{1}_ZN3gmx20HostAllocationPolicyC1ENS_13PinningPolicyE"]
    pub fn gmx_HostAllocationPolicy_HostAllocationPolicy(
        this: *mut gmx_HostAllocationPolicy,
        policy: gmx_PinningPolicy,
    );
}
impl gmx_HostAllocationPolicy {
    #[inline]
    pub unsafe fn alignment(&self) -> usize {
        gmx_HostAllocationPolicy_alignment(self)
    }
    #[inline]
    pub unsafe fn malloc(&self, bytes: usize) -> *mut ::std::os::raw::c_void {
        gmx_HostAllocationPolicy_malloc(self, bytes)
    }
    #[inline]
    pub unsafe fn free(&self, buffer: *mut ::std::os::raw::c_void) {
        gmx_HostAllocationPolicy_free(self, buffer)
    }
    #[inline]
    pub unsafe fn new(policy: gmx_PinningPolicy) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        gmx_HostAllocationPolicy_HostAllocationPolicy(__bindgen_tmp.as_mut_ptr(), policy);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gmx_AwhHistory {
    _unused: [u8; 0],
}
pub const Compartment_A: Compartment = 0;
pub const Compartment_B: Compartment = 1;
pub const Compartment_Count: Compartment = 2;
#[doc = "! \\brief The two compartments for CompEL setups."]
pub type Compartment = ::std::os::raw::c_int;
pub const EnsembleTemperatureSetting_NotAvailable: EnsembleTemperatureSetting = 0;
#[doc = "! There is no ensemble temperature available for the system"]
pub const EnsembleTemperatureSetting_Constant: EnsembleTemperatureSetting = 1;
#[doc = "! The ensemble temperature is fixed over time"]
pub const EnsembleTemperatureSetting_Variable: EnsembleTemperatureSetting = 2;
#[doc = "! The ensemble temperature varies over time"]
pub const EnsembleTemperatureSetting_Auto: EnsembleTemperatureSetting = 3;
#[doc = "! Auto setting for grompp, should not be present in tpr and mdrun"]
pub const EnsembleTemperatureSetting_Count: EnsembleTemperatureSetting = 4;
#[doc = "! Auto setting for grompp, should not be present in tpr and mdrun"]
pub const EnsembleTemperatureSetting_Default: EnsembleTemperatureSetting = 3;
#[doc = "! Whether and what kind of ensemble temperature we have for the system"]
pub type EnsembleTemperatureSetting = ::std::os::raw::c_int;
pub const TemperatureCoupling_No: TemperatureCoupling = 0;
pub const TemperatureCoupling_Berendsen: TemperatureCoupling = 1;
pub const TemperatureCoupling_NoseHoover: TemperatureCoupling = 2;
pub const TemperatureCoupling_Yes: TemperatureCoupling = 3;
pub const TemperatureCoupling_Andersen: TemperatureCoupling = 4;
pub const TemperatureCoupling_AndersenMassive: TemperatureCoupling = 5;
pub const TemperatureCoupling_VRescale: TemperatureCoupling = 6;
pub const TemperatureCoupling_Count: TemperatureCoupling = 7;
pub const TemperatureCoupling_Default: TemperatureCoupling = 0;
#[doc = " \\brief Temperature coupling type\n\n yes is an alias for berendsen\n\n Note: Keep `Count` as the second-to-last entry, and `Default` as the last entry -\n       this is needed to keep EnumerationWrapper, EnumerationArray and (de)serialization\n       working."]
pub type TemperatureCoupling = ::std::os::raw::c_int;
pub const PressureCoupling_No: PressureCoupling = 0;
pub const PressureCoupling_Berendsen: PressureCoupling = 1;
pub const PressureCoupling_ParrinelloRahman: PressureCoupling = 2;
pub const PressureCoupling_Isotropic: PressureCoupling = 3;
pub const PressureCoupling_Mttk: PressureCoupling = 4;
pub const PressureCoupling_CRescale: PressureCoupling = 5;
pub const PressureCoupling_Count: PressureCoupling = 6;
pub const PressureCoupling_Default: PressureCoupling = 0;
#[doc = " \\brief Pressure coupling types\n\n isotropic is an alias for berendsen\n\n Note: Keep `Count` as the second-to-last entry, and `Default` as the last entry -\n       this is needed to keep EnumerationWrapper, EnumerationArray and (de)serialization\n       working."]
pub type PressureCoupling = ::std::os::raw::c_int;
pub const RefCoordScaling_No: RefCoordScaling = 0;
pub const RefCoordScaling_All: RefCoordScaling = 1;
pub const RefCoordScaling_Com: RefCoordScaling = 2;
pub const RefCoordScaling_Count: RefCoordScaling = 3;
pub const RefCoordScaling_Default: RefCoordScaling = 0;
#[doc = "! Relative coordinate scaling type for position restraints."]
pub type RefCoordScaling = ::std::os::raw::c_int;
pub const PressureCouplingType_Isotropic: PressureCouplingType = 0;
pub const PressureCouplingType_SemiIsotropic: PressureCouplingType = 1;
pub const PressureCouplingType_Anisotropic: PressureCouplingType = 2;
pub const PressureCouplingType_SurfaceTension: PressureCouplingType = 3;
pub const PressureCouplingType_Count: PressureCouplingType = 4;
pub const PressureCouplingType_Default: PressureCouplingType = 0;
#[doc = "! Pressure coupling type"]
pub type PressureCouplingType = ::std::os::raw::c_int;
pub const CutoffScheme_Verlet: CutoffScheme = 0;
pub const CutoffScheme_Group: CutoffScheme = 1;
pub const CutoffScheme_Count: CutoffScheme = 2;
pub const CutoffScheme_Default: CutoffScheme = 0;
#[doc = "! \\\\brief Cutoff scheme"]
pub type CutoffScheme = ::std::os::raw::c_int;
pub const InteractionModifiers_PotShiftVerletUnsupported: InteractionModifiers = 0;
pub const InteractionModifiers_PotShift: InteractionModifiers = 1;
pub const InteractionModifiers_None: InteractionModifiers = 2;
pub const InteractionModifiers_PotSwitch: InteractionModifiers = 3;
pub const InteractionModifiers_ExactCutoff: InteractionModifiers = 4;
pub const InteractionModifiers_ForceSwitch: InteractionModifiers = 5;
pub const InteractionModifiers_Count: InteractionModifiers = 6;
pub const InteractionModifiers_Default: InteractionModifiers = 0;
#[doc = " \\brief Coulomb / VdW interaction modifiers.\n\n grompp replaces eintmodPOTSHIFT_VERLET_UNSUPPORTED by eintmodPOTSHIFT.\n Exactcutoff is only used by Reaction-field-zero, and is not user-selectable."]
pub type InteractionModifiers = ::std::os::raw::c_int;
pub const CoulombInteractionType_Cut: CoulombInteractionType = 0;
pub const CoulombInteractionType_RF: CoulombInteractionType = 1;
pub const CoulombInteractionType_GRFNotused: CoulombInteractionType = 2;
pub const CoulombInteractionType_Pme: CoulombInteractionType = 3;
pub const CoulombInteractionType_Ewald: CoulombInteractionType = 4;
pub const CoulombInteractionType_P3mAD: CoulombInteractionType = 5;
pub const CoulombInteractionType_Poisson: CoulombInteractionType = 6;
pub const CoulombInteractionType_Switch: CoulombInteractionType = 7;
pub const CoulombInteractionType_Shift: CoulombInteractionType = 8;
pub const CoulombInteractionType_User: CoulombInteractionType = 9;
pub const CoulombInteractionType_GBNotused: CoulombInteractionType = 10;
pub const CoulombInteractionType_RFNecUnsupported: CoulombInteractionType = 11;
pub const CoulombInteractionType_EncadShiftNotused: CoulombInteractionType = 12;
pub const CoulombInteractionType_PmeUser: CoulombInteractionType = 13;
pub const CoulombInteractionType_PmeSwitch: CoulombInteractionType = 14;
pub const CoulombInteractionType_PmeUserSwitch: CoulombInteractionType = 15;
pub const CoulombInteractionType_RFZero: CoulombInteractionType = 16;
pub const CoulombInteractionType_Count: CoulombInteractionType = 17;
pub const CoulombInteractionType_Default: CoulombInteractionType = 0;
#[doc = " \\brief Cut-off treatment for Coulomb"]
pub type CoulombInteractionType = ::std::os::raw::c_int;
pub const EwaldGeometry_ThreeD: EwaldGeometry = 0;
pub const EwaldGeometry_ThreeDC: EwaldGeometry = 1;
pub const EwaldGeometry_Count: EwaldGeometry = 2;
pub const EwaldGeometry_Default: EwaldGeometry = 0;
#[doc = "! Ewald geometry."]
pub type EwaldGeometry = ::std::os::raw::c_int;
pub const VanDerWaalsType_Cut: VanDerWaalsType = 0;
pub const VanDerWaalsType_Switch: VanDerWaalsType = 1;
pub const VanDerWaalsType_Shift: VanDerWaalsType = 2;
pub const VanDerWaalsType_User: VanDerWaalsType = 3;
pub const VanDerWaalsType_EncadShiftUnused: VanDerWaalsType = 4;
pub const VanDerWaalsType_Pme: VanDerWaalsType = 5;
pub const VanDerWaalsType_Count: VanDerWaalsType = 6;
pub const VanDerWaalsType_Default: VanDerWaalsType = 0;
#[doc = "! Van der Waals interaction treatment"]
pub type VanDerWaalsType = ::std::os::raw::c_int;
pub const LongRangeVdW_Geom: LongRangeVdW = 0;
pub const LongRangeVdW_LB: LongRangeVdW = 1;
pub const LongRangeVdW_Count: LongRangeVdW = 2;
pub const LongRangeVdW_Default: LongRangeVdW = 0;
#[doc = "! Type of long-range VdW treatment of combination rules"]
pub type LongRangeVdW = ::std::os::raw::c_int;
pub const IntegrationAlgorithm_MD: IntegrationAlgorithm = 0;
pub const IntegrationAlgorithm_Steep: IntegrationAlgorithm = 1;
pub const IntegrationAlgorithm_CG: IntegrationAlgorithm = 2;
pub const IntegrationAlgorithm_BD: IntegrationAlgorithm = 3;
pub const IntegrationAlgorithm_SD2Removed: IntegrationAlgorithm = 4;
pub const IntegrationAlgorithm_NM: IntegrationAlgorithm = 5;
pub const IntegrationAlgorithm_LBFGS: IntegrationAlgorithm = 6;
pub const IntegrationAlgorithm_TPI: IntegrationAlgorithm = 7;
pub const IntegrationAlgorithm_TPIC: IntegrationAlgorithm = 8;
pub const IntegrationAlgorithm_SD1: IntegrationAlgorithm = 9;
pub const IntegrationAlgorithm_VV: IntegrationAlgorithm = 10;
pub const IntegrationAlgorithm_VVAK: IntegrationAlgorithm = 11;
pub const IntegrationAlgorithm_Mimic: IntegrationAlgorithm = 12;
pub const IntegrationAlgorithm_Count: IntegrationAlgorithm = 13;
pub const IntegrationAlgorithm_Default: IntegrationAlgorithm = 0;
#[doc = " \\brief Integrator algorithm\n\n eiSD2 has been removed, but we keep a renamed enum entry,\n so we can refuse to do MD with such .tpr files.\n eiVV is normal velocity verlet\n eiVVAK uses 1/2*(KE(t-dt/2)+KE(t+dt/2)) as the kinetic energy,\n and the half step kinetic energy for temperature control"]
pub type IntegrationAlgorithm = ::std::os::raw::c_int;
pub const ConstraintAlgorithm_Lincs: ConstraintAlgorithm = 0;
pub const ConstraintAlgorithm_Shake: ConstraintAlgorithm = 1;
pub const ConstraintAlgorithm_Count: ConstraintAlgorithm = 2;
pub const ConstraintAlgorithm_Default: ConstraintAlgorithm = 0;
#[doc = "! Constraint algorithm"]
pub type ConstraintAlgorithm = ::std::os::raw::c_int;
pub const DistanceRestraintRefinement_None: DistanceRestraintRefinement = 0;
pub const DistanceRestraintRefinement_Simple: DistanceRestraintRefinement = 1;
pub const DistanceRestraintRefinement_Ensemble: DistanceRestraintRefinement = 2;
pub const DistanceRestraintRefinement_Count: DistanceRestraintRefinement = 3;
pub const DistanceRestraintRefinement_Default: DistanceRestraintRefinement = 0;
#[doc = "! Distance restraint refinement algorithm"]
pub type DistanceRestraintRefinement = ::std::os::raw::c_int;
pub const DistanceRestraintWeighting_Conservative: DistanceRestraintWeighting = 0;
pub const DistanceRestraintWeighting_Equal: DistanceRestraintWeighting = 1;
pub const DistanceRestraintWeighting_Count: DistanceRestraintWeighting = 2;
pub const DistanceRestraintWeighting_Default: DistanceRestraintWeighting = 0;
#[doc = "! Distance restraints weighting type"]
pub type DistanceRestraintWeighting = ::std::os::raw::c_int;
pub const SimulatedTempering_Geometric: SimulatedTempering = 0;
pub const SimulatedTempering_Exponential: SimulatedTempering = 1;
pub const SimulatedTempering_Linear: SimulatedTempering = 2;
pub const SimulatedTempering_Count: SimulatedTempering = 3;
pub const SimulatedTempering_Default: SimulatedTempering = 0;
#[doc = "! Simulated tempering methods."]
pub type SimulatedTempering = ::std::os::raw::c_int;
#[doc = "! there are no evaluations at other states"]
pub const FreeEnergyPerturbationType_No: FreeEnergyPerturbationType = 0;
#[doc = "! treated equivalently to Static"]
pub const FreeEnergyPerturbationType_Yes: FreeEnergyPerturbationType = 1;
#[doc = "! then lambdas do not change during the simulation"]
pub const FreeEnergyPerturbationType_Static: FreeEnergyPerturbationType = 2;
#[doc = "! then the states change monotonically throughout the simulation"]
pub const FreeEnergyPerturbationType_SlowGrowth: FreeEnergyPerturbationType = 3;
#[doc = "! then expanded ensemble simulations are occurring"]
pub const FreeEnergyPerturbationType_Expanded: FreeEnergyPerturbationType = 4;
#[doc = "! then expanded ensemble simulations are occurring"]
pub const FreeEnergyPerturbationType_Count: FreeEnergyPerturbationType = 5;
#[doc = "! then expanded ensemble simulations are occurring"]
pub const FreeEnergyPerturbationType_Default: FreeEnergyPerturbationType = 0;
#[doc = " \\brief Free energy perturbation type"]
pub type FreeEnergyPerturbationType = ::std::os::raw::c_int;
pub const FreeEnergyPerturbationCouplingType_Fep: FreeEnergyPerturbationCouplingType = 0;
pub const FreeEnergyPerturbationCouplingType_Mass: FreeEnergyPerturbationCouplingType = 1;
pub const FreeEnergyPerturbationCouplingType_Coul: FreeEnergyPerturbationCouplingType = 2;
pub const FreeEnergyPerturbationCouplingType_Vdw: FreeEnergyPerturbationCouplingType = 3;
pub const FreeEnergyPerturbationCouplingType_Bonded: FreeEnergyPerturbationCouplingType = 4;
pub const FreeEnergyPerturbationCouplingType_Restraint: FreeEnergyPerturbationCouplingType = 5;
pub const FreeEnergyPerturbationCouplingType_Temperature: FreeEnergyPerturbationCouplingType = 6;
pub const FreeEnergyPerturbationCouplingType_Count: FreeEnergyPerturbationCouplingType = 7;
pub const FreeEnergyPerturbationCouplingType_Default: FreeEnergyPerturbationCouplingType = 0;
#[doc = "! Free energy perturbation coupling types."]
pub type FreeEnergyPerturbationCouplingType = ::std::os::raw::c_int;
pub const FreeEnergyPrintEnergy_No: FreeEnergyPrintEnergy = 0;
pub const FreeEnergyPrintEnergy_Total: FreeEnergyPrintEnergy = 1;
pub const FreeEnergyPrintEnergy_Potential: FreeEnergyPrintEnergy = 2;
pub const FreeEnergyPrintEnergy_Yes: FreeEnergyPrintEnergy = 3;
pub const FreeEnergyPrintEnergy_Count: FreeEnergyPrintEnergy = 4;
pub const FreeEnergyPrintEnergy_Default: FreeEnergyPrintEnergy = 0;
#[doc = " \\brief What to print for free energy calculations\n\n Printing the energy to the free energy dhdl file.\n Yes is an alias to Total, and\n will be converted in readir, so we never have to account for it in code."]
pub type FreeEnergyPrintEnergy = ::std::os::raw::c_int;
#[doc = "! don't calculate"]
pub const LambdaWeightCalculation_No: LambdaWeightCalculation = 0;
#[doc = "! using the metropolis criteria"]
pub const LambdaWeightCalculation_Metropolis: LambdaWeightCalculation = 1;
#[doc = "! using the Barker critera for transition weights, also called unoptimized Bennett"]
pub const LambdaWeightCalculation_Barker: LambdaWeightCalculation = 2;
#[doc = "! using Barker + minimum variance for weights"]
pub const LambdaWeightCalculation_Minvar: LambdaWeightCalculation = 3;
#[doc = "! Wang-Landu (using visitation counts)"]
pub const LambdaWeightCalculation_WL: LambdaWeightCalculation = 4;
#[doc = "! Weighted Wang-Landau (using optimized Gibbs weighted visitation counts)"]
pub const LambdaWeightCalculation_WWL: LambdaWeightCalculation = 5;
#[doc = "! Weighted Wang-Landau (using optimized Gibbs weighted visitation counts)"]
pub const LambdaWeightCalculation_Count: LambdaWeightCalculation = 6;
#[doc = "! Weighted Wang-Landau (using optimized Gibbs weighted visitation counts)"]
pub const LambdaWeightCalculation_Default: LambdaWeightCalculation = 0;
#[doc = " \\brief How the lambda weights are calculated"]
pub type LambdaWeightCalculation = ::std::os::raw::c_int;
#[doc = "! don't calculate move"]
pub const LambdaMoveCalculation_No: LambdaMoveCalculation = 0;
#[doc = "! using the Metropolis criteria, and 50% up and down"]
pub const LambdaMoveCalculation_Metropolis: LambdaMoveCalculation = 1;
#[doc = "! using the Barker criteria, and 50% up and down"]
pub const LambdaMoveCalculation_Barker: LambdaMoveCalculation = 2;
#[doc = "! computing the transition using the marginalized probabilities of the lambdas"]
pub const LambdaMoveCalculation_Gibbs: LambdaMoveCalculation = 3;
#[doc = " \\brief\n using the metropolized version of Gibbs\n\n Monte Carlo Strategies in Scientific computing, Liu, p. 134"]
pub const LambdaMoveCalculation_MetropolisGibbs: LambdaMoveCalculation = 4;
#[doc = " \\brief\n using the metropolized version of Gibbs\n\n Monte Carlo Strategies in Scientific computing, Liu, p. 134"]
pub const LambdaMoveCalculation_Count: LambdaMoveCalculation = 5;
#[doc = " \\brief\n using the metropolized version of Gibbs\n\n Monte Carlo Strategies in Scientific computing, Liu, p. 134"]
pub const LambdaMoveCalculation_Default: LambdaMoveCalculation = 0;
#[doc = " \\brief How moves in lambda are calculated"]
pub type LambdaMoveCalculation = ::std::os::raw::c_int;
#[doc = "! never stop, weights keep going"]
pub const LambdaWeightWillReachEquilibrium_No: LambdaWeightWillReachEquilibrium = 0;
#[doc = "! fix the weights from the beginning; no movement"]
pub const LambdaWeightWillReachEquilibrium_Yes: LambdaWeightWillReachEquilibrium = 1;
#[doc = "! stop when the WL-delta falls below a certain level"]
pub const LambdaWeightWillReachEquilibrium_WLDelta: LambdaWeightWillReachEquilibrium = 2;
#[doc = "! stop when we have a certain number of samples at every step"]
pub const LambdaWeightWillReachEquilibrium_NumAtLambda: LambdaWeightWillReachEquilibrium = 3;
#[doc = "! stop when we've run a certain total number of steps"]
pub const LambdaWeightWillReachEquilibrium_Steps: LambdaWeightWillReachEquilibrium = 4;
#[doc = "! stop when we've run a certain total number of samples"]
pub const LambdaWeightWillReachEquilibrium_Samples: LambdaWeightWillReachEquilibrium = 5;
#[doc = "! stop when the ratio of samples (lowest to highest) is sufficiently large"]
pub const LambdaWeightWillReachEquilibrium_Ratio: LambdaWeightWillReachEquilibrium = 6;
#[doc = "! stop when the ratio of samples (lowest to highest) is sufficiently large"]
pub const LambdaWeightWillReachEquilibrium_Count: LambdaWeightWillReachEquilibrium = 7;
#[doc = "! stop when the ratio of samples (lowest to highest) is sufficiently large"]
pub const LambdaWeightWillReachEquilibrium_Default: LambdaWeightWillReachEquilibrium = 0;
#[doc = " \\brief How we decide whether weights have reached equilibrium"]
pub type LambdaWeightWillReachEquilibrium = ::std::os::raw::c_int;
pub const SeparateDhdlFile_Yes: SeparateDhdlFile = 0;
pub const SeparateDhdlFile_No: SeparateDhdlFile = 1;
pub const SeparateDhdlFile_Count: SeparateDhdlFile = 2;
pub const SeparateDhdlFile_Default: SeparateDhdlFile = 0;
#[doc = " \\brief separate_dhdl_file selection\n\n NOTE: YES is the first one. Do NOT interpret this one as a gmx_bool\n Why was this done this way, just ........."]
pub type SeparateDhdlFile = ::std::os::raw::c_int;
pub const DhDlDerivativeCalculation_Yes: DhDlDerivativeCalculation = 0;
pub const DhDlDerivativeCalculation_No: DhDlDerivativeCalculation = 1;
pub const DhDlDerivativeCalculation_Count: DhDlDerivativeCalculation = 2;
pub const DhDlDerivativeCalculation_Default: DhDlDerivativeCalculation = 0;
#[doc = " \\brief dhdl_derivatives selection \\\n\n NOTE: YES is the first one. Do NOT interpret this one as a gmx_bool\n Why was this done this way, just ........."]
pub type DhDlDerivativeCalculation = ::std::os::raw::c_int;
pub const SoftcoreType_Beutler: SoftcoreType = 0;
pub const SoftcoreType_Gapsys: SoftcoreType = 1;
pub const SoftcoreType_Count: SoftcoreType = 2;
pub const SoftcoreType_Default: SoftcoreType = 0;
#[doc = " \\brief soft-core function \\\n\n Distinguishes between soft-core functions in the input."]
pub type SoftcoreType = ::std::os::raw::c_int;
pub const DispersionCorrectionType_No: DispersionCorrectionType = 0;
pub const DispersionCorrectionType_EnerPres: DispersionCorrectionType = 1;
pub const DispersionCorrectionType_Ener: DispersionCorrectionType = 2;
pub const DispersionCorrectionType_AllEnerPres: DispersionCorrectionType = 3;
pub const DispersionCorrectionType_AllEner: DispersionCorrectionType = 4;
pub const DispersionCorrectionType_Count: DispersionCorrectionType = 5;
pub const DispersionCorrectionType_Default: DispersionCorrectionType = 0;
#[doc = "! Dispersion correction."]
pub type DispersionCorrectionType = ::std::os::raw::c_int;
pub const SimulatedAnnealing_No: SimulatedAnnealing = 0;
pub const SimulatedAnnealing_Single: SimulatedAnnealing = 1;
pub const SimulatedAnnealing_Periodic: SimulatedAnnealing = 2;
pub const SimulatedAnnealing_Count: SimulatedAnnealing = 3;
pub const SimulatedAnnealing_Default: SimulatedAnnealing = 0;
#[doc = "! Algorithm for simulated annealing."]
pub type SimulatedAnnealing = ::std::os::raw::c_int;
pub const WallType_NineThree: WallType = 0;
pub const WallType_TenFour: WallType = 1;
pub const WallType_Table: WallType = 2;
pub const WallType_TwelveSix: WallType = 3;
pub const WallType_Count: WallType = 4;
pub const WallType_Default: WallType = 0;
#[doc = "! Wall types."]
pub type WallType = ::std::os::raw::c_int;
pub const EnforcedRotationGroupType_Iso: EnforcedRotationGroupType = 0;
pub const EnforcedRotationGroupType_Isopf: EnforcedRotationGroupType = 1;
pub const EnforcedRotationGroupType_Pm: EnforcedRotationGroupType = 2;
pub const EnforcedRotationGroupType_Pmpf: EnforcedRotationGroupType = 3;
pub const EnforcedRotationGroupType_Rm: EnforcedRotationGroupType = 4;
pub const EnforcedRotationGroupType_Rmpf: EnforcedRotationGroupType = 5;
pub const EnforcedRotationGroupType_Rm2: EnforcedRotationGroupType = 6;
pub const EnforcedRotationGroupType_Rm2pf: EnforcedRotationGroupType = 7;
pub const EnforcedRotationGroupType_Flex: EnforcedRotationGroupType = 8;
pub const EnforcedRotationGroupType_Flext: EnforcedRotationGroupType = 9;
pub const EnforcedRotationGroupType_Flex2: EnforcedRotationGroupType = 10;
pub const EnforcedRotationGroupType_Flex2t: EnforcedRotationGroupType = 11;
pub const EnforcedRotationGroupType_Count: EnforcedRotationGroupType = 12;
pub const EnforcedRotationGroupType_Default: EnforcedRotationGroupType = 0;
#[doc = "! Enforced rotation groups."]
pub type EnforcedRotationGroupType = ::std::os::raw::c_int;
pub const RotationGroupFitting_Rmsd: RotationGroupFitting = 0;
pub const RotationGroupFitting_Norm: RotationGroupFitting = 1;
pub const RotationGroupFitting_Pot: RotationGroupFitting = 2;
pub const RotationGroupFitting_Count: RotationGroupFitting = 3;
pub const RotationGroupFitting_Default: RotationGroupFitting = 0;
#[doc = "! Rotation group fitting type"]
pub type RotationGroupFitting = ::std::os::raw::c_int;
pub const SwapType_No: SwapType = 0;
pub const SwapType_X: SwapType = 1;
pub const SwapType_Y: SwapType = 2;
pub const SwapType_Z: SwapType = 3;
pub const SwapType_Count: SwapType = 4;
pub const SwapType_Default: SwapType = 0;
#[doc = " \\brief Direction along which ion/water swaps happen\n\n Part of \"Computational Electrophysiology\" (CompEL) setups"]
pub type SwapType = ::std::os::raw::c_int;
pub const ComRemovalAlgorithm_Linear: ComRemovalAlgorithm = 0;
pub const ComRemovalAlgorithm_Angular: ComRemovalAlgorithm = 1;
pub const ComRemovalAlgorithm_No: ComRemovalAlgorithm = 2;
pub const ComRemovalAlgorithm_LinearAccelerationCorrection: ComRemovalAlgorithm = 3;
pub const ComRemovalAlgorithm_Count: ComRemovalAlgorithm = 4;
pub const ComRemovalAlgorithm_Default: ComRemovalAlgorithm = 0;
#[doc = "! Center of mass motion removal algorithm."]
pub type ComRemovalAlgorithm = ::std::os::raw::c_int;
#[doc = "!< Periodic boundaries in all dimensions."]
pub const PbcType_Xyz: PbcType = 0;
#[doc = "!< No periodic boundaries."]
pub const PbcType_No: PbcType = 1;
#[doc = "!< Only two dimensions are periodic."]
pub const PbcType_XY: PbcType = 2;
#[doc = "!< Screw."]
pub const PbcType_Screw: PbcType = 3;
#[doc = "!< The type of PBC is not set or invalid."]
pub const PbcType_Unset: PbcType = 4;
pub const PbcType_Count: PbcType = 5;
pub const PbcType_Default: PbcType = 0;
#[doc = "! Enumeration that contains all supported periodic boundary setups."]
pub type PbcType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pull_params_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_grpopts {
    #[doc = "! Number of T-Coupl groups"]
    pub ngtc: ::std::os::raw::c_int,
    #[doc = "! Number of of Nose-Hoover chains per group"]
    pub nhchainlength: ::std::os::raw::c_int,
    #[doc = "! Number of Accelerate groups"]
    pub ngacc: ::std::os::raw::c_int,
    #[doc = "! Number of Freeze groups"]
    pub ngfrz: ::std::os::raw::c_int,
    #[doc = "! Number of Energy groups"]
    pub ngener: ::std::os::raw::c_int,
    #[doc = "! Number of degrees of freedom in a temperature-coupling group"]
    pub nrdf: *mut real,
    #[doc = "! Coupling temperature\tper group"]
    pub ref_t: *mut real,
    #[doc = "! No/simple/periodic simulated annealing for each group"]
    pub annealing: *mut SimulatedAnnealing,
    #[doc = "! Number of annealing time points per group"]
    pub anneal_npoints: *mut ::std::os::raw::c_int,
    #[doc = "! For each group: Time points"]
    pub anneal_time: *mut *mut real,
    #[doc = "! For each group: Temperature at these times. Final temp after all intervals is ref_t"]
    pub anneal_temp: *mut *mut real,
    #[doc = "! Tau coupling time"]
    pub tau_t: *mut real,
    #[doc = "! Acceleration per group"]
    pub acceleration: *mut rvec,
    #[doc = "! Whether the group will be frozen in each direction"]
    pub nFreeze: *mut ivec,
    #[doc = "! Exclusions/tables of energy group pairs"]
    pub egp_flags: *mut ::std::os::raw::c_int,
    #[doc = "! Number of QM groups"]
    pub ngQM: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct t_simtemp {
    #[doc = "! Simulated temperature scaling; linear or exponential"]
    pub eSimTempScale: SimulatedTempering,
    #[doc = "! The low temperature for simulated tempering"]
    pub simtemp_low: real,
    #[doc = "! The high temperature for simulated tempering"]
    pub simtemp_high: real,
    #[doc = "! The range of temperatures used for simulated tempering"]
    pub temperatures: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct t_lambda {
    #[doc = "! The frequency for calculating dhdl"]
    pub nstdhdl: ::std::os::raw::c_int,
    #[doc = "! Fractional value of lambda (usually will use init_fep_state, this will only be for slow growth, and for legacy free energy code. Only has a valid value if positive)"]
    pub init_lambda: f64,
    #[doc = "! The initial number of the state"]
    pub init_fep_state: ::std::os::raw::c_int,
    #[doc = "! Change of lambda per time step (fraction of (0.1)"]
    pub delta_lambda: f64,
    #[doc = "! Print no, total or potential energies in dhdl"]
    pub edHdLPrintEnergy: FreeEnergyPrintEnergy,
    #[doc = "! The number of foreign lambda points"]
    pub n_lambda: ::std::os::raw::c_int,
    #[doc = "! The array of all lambda values"]
    pub all_lambda: [u64; 21usize],
    #[doc = "! The number of neighboring lambda states to calculate the energy for in up and down directions (-1 for all)"]
    pub lambda_neighbors: ::std::os::raw::c_int,
    #[doc = "! The first lambda to calculate energies for"]
    pub lambda_start_n: ::std::os::raw::c_int,
    #[doc = "! The last lambda +1 to calculate energies for"]
    pub lambda_stop_n: ::std::os::raw::c_int,
    #[doc = "! Free energy soft-core parameter"]
    pub sc_alpha: real,
    #[doc = "! Lambda power for soft-core interactions"]
    pub sc_power: ::std::os::raw::c_int,
    #[doc = "! R power for soft-core interactions"]
    pub sc_r_power: real,
    #[doc = "! Free energy soft-core sigma when c6 or c12=0"]
    pub sc_sigma: real,
    #[doc = "! Free energy soft-core sigma for ?????"]
    pub sc_sigma_min: real,
    #[doc = "! Use softcore for the coulomb portion as well (default FALSE)"]
    pub bScCoul: bool,
    #[doc = "! The specific soft-core function to use"]
    pub softcoreFunction: SoftcoreType,
    #[doc = "! scale for the linearization point for the vdw interaction with gapsys soft-core"]
    pub scGapsysScaleLinpointLJ: real,
    #[doc = "! scale for the linearization point for the coulomb interaction with gapsys soft-core"]
    pub scGapsysScaleLinpointQ: real,
    #[doc = "! lower bound for c12/c6 in gapsys soft-core"]
    pub scGapsysSigmaLJ: real,
    #[doc = "! Whether to print the dvdl term associated with this term; if it is not specified as separate, it is lumped with the FEP term"]
    pub separate_dvdl: [u8; 7usize],
    #[doc = "! Whether to write a separate dhdl.xvg file note: NOT a gmx_bool, but an enum"]
    pub separate_dhdl_file: SeparateDhdlFile,
    #[doc = "! Whether to calculate+write dhdl derivatives note: NOT a gmx_bool, but an enum"]
    pub dhdl_derivatives: DhDlDerivativeCalculation,
    #[doc = "! The maximum table size for the dH histogram"]
    pub dh_hist_size: ::std::os::raw::c_int,
    #[doc = "! The spacing for the dH histogram"]
    pub dh_hist_spacing: f64,
}
#[repr(C)]
#[derive(Debug)]
pub struct t_expanded {
    #[doc = "! The frequency of expanded ensemble state changes"]
    pub nstexpanded: ::std::os::raw::c_int,
    #[doc = "! Which type of move updating do we use for lambda monte carlo (or no for none)"]
    pub elamstats: LambdaWeightCalculation,
    #[doc = "! What move set will be we using for state space moves"]
    pub elmcmove: LambdaMoveCalculation,
    #[doc = "! The method we use to decide of we have equilibrated the weights"]
    pub elmceq: LambdaWeightWillReachEquilibrium,
    #[doc = "! The minumum number of samples at each lambda for deciding whether we have reached a minimum"]
    pub equil_n_at_lam: ::std::os::raw::c_int,
    #[doc = "! Wang-Landau delta at which we stop equilibrating weights"]
    pub equil_wl_delta: real,
    #[doc = "! Use the ratio of weights (ratio of minimum to maximum) to decide when to stop equilibrating"]
    pub equil_ratio: real,
    #[doc = "! After equil_steps steps we stop equilibrating the weights"]
    pub equil_steps: ::std::os::raw::c_int,
    #[doc = "! After equil_samples total samples (steps/nstfep), we stop equilibrating the weights"]
    pub equil_samples: ::std::os::raw::c_int,
    #[doc = "! Random number seed for lambda mc switches"]
    pub lmc_seed: ::std::os::raw::c_int,
    #[doc = "! Whether to use minumum variance weighting"]
    pub minvar: bool,
    #[doc = "! The number of samples needed before kicking into minvar routine"]
    pub minvarmin: ::std::os::raw::c_int,
    #[doc = "! The offset for the variance in MinVar"]
    pub minvar_const: real,
    #[doc = "! Range of cvalues used for BAR"]
    pub c_range: ::std::os::raw::c_int,
    #[doc = "! Whether to print symmetrized matrices"]
    pub bSymmetrizedTMatrix: bool,
    #[doc = "! How frequently to print the transition matrices"]
    pub nstTij: ::std::os::raw::c_int,
    #[doc = "! Number of repetitions in the MC lambda jumps MRS -- VERIFY THIS"]
    pub lmc_repeats: ::std::os::raw::c_int,
    #[doc = "! Minimum number of samples for each state before free sampling MRS -- VERIFY THIS!"]
    pub lmc_forced_nstart: ::std::os::raw::c_int,
    #[doc = "! Distance in lambda space for the gibbs interval"]
    pub gibbsdeltalam: ::std::os::raw::c_int,
    #[doc = "! Scaling factor for Wang-Landau"]
    pub wl_scale: real,
    #[doc = "! Ratio between largest and smallest number for freezing the weights"]
    pub wl_ratio: real,
    #[doc = "! Starting delta for Wang-Landau"]
    pub init_wl_delta: real,
    #[doc = "! Use one over t convergence for Wang-Landau when the delta get sufficiently small"]
    pub bWLoneovert: bool,
    #[doc = "! Did we initialize the weights? TODO: REMOVE FOR 5.0, no longer needed with new logic"]
    pub bInit_weights: bool,
    #[doc = "! To override the main temperature, or define it if it's not defined"]
    pub mc_temp: real,
    #[doc = "! User-specified initial weights to start with"]
    pub init_lambda_weights: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct t_rotgrp {
    #[doc = "! Rotation type for this group"]
    pub eType: EnforcedRotationGroupType,
    #[doc = "! Use mass-weighed positions?"]
    pub bMassW: bool,
    #[doc = "! Number of atoms in the group"]
    pub nat: ::std::os::raw::c_int,
    #[doc = "! The global atoms numbers"]
    pub ind: *mut ::std::os::raw::c_int,
    #[doc = "! The reference positions (which have not been centered)"]
    pub x_ref_original: [u64; 3usize],
    #[doc = "! The normalized rotation vector"]
    pub inputVec: rvec,
    #[doc = "! Rate of rotation (degree/ps)"]
    pub rate: real,
    #[doc = "! Force constant (kJ/(mol nm^2)"]
    pub k: real,
    #[doc = "! Pivot point of rotation axis (nm)"]
    pub pivot: rvec,
    #[doc = "! Type of fit to determine actual group angle"]
    pub eFittype: RotationGroupFitting,
    #[doc = "! Number of angles around the reference angle for which the rotation potential is also evaluated (for fit type 'potential' only)"]
    pub PotAngle_nstep: ::std::os::raw::c_int,
    #[doc = "! Distance between two angles in degrees (for fit type 'potential' only)"]
    pub PotAngle_step: real,
    #[doc = "! Slab distance (nm)"]
    pub slab_dist: real,
    #[doc = "! Minimum value the gaussian must have so that the force is actually evaluated"]
    pub min_gaussian: real,
    #[doc = "! Additive constant for radial motion2 and flexible2 potentials (nm^2)"]
    pub eps: real,
}
#[repr(C)]
#[derive(Debug)]
pub struct t_rot {
    #[doc = "! Output frequency for main rotation outfile"]
    pub nstrout: ::std::os::raw::c_int,
    #[doc = "! Output frequency for per-slab data"]
    pub nstsout: ::std::os::raw::c_int,
    #[doc = "! Groups to rotate"]
    pub grp: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_IMD {
    #[doc = "! Number of interactive atoms"]
    pub nat: ::std::os::raw::c_int,
    #[doc = "! The global indices of the interactive atoms"]
    pub ind: *mut ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_swapGroup {
    #[doc = "! Name of the swap group, e.g. NA, CL, SOL"]
    pub molname: *mut ::std::os::raw::c_char,
    #[doc = "! Number of atoms in this group"]
    pub nat: ::std::os::raw::c_int,
    #[doc = "! The global ion group atoms numbers"]
    pub ind: *mut ::std::os::raw::c_int,
    #[doc = "! Requested number of molecules of this type per compartment"]
    pub nmolReq: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_swapcoords {
    #[doc = "! Period between when a swap is attempted"]
    pub nstswap: ::std::os::raw::c_int,
    #[doc = "! Use mass-weighted positions in split group"]
    pub massw_split: [bool; 2usize],
    #[doc = " \\brief Split cylinders defined by radius, upper and lower\n extension. The split cylinders define the channels and are\n each anchored in the center of the split group */\n/**@{"]
    pub cyl0r: real,
    #[doc = " \\brief Split cylinders defined by radius, upper and lower\n extension. The split cylinders define the channels and are\n each anchored in the center of the split group */\n/**@{"]
    pub cyl1r: real,
    pub cyl0u: real,
    pub cyl1u: real,
    pub cyl0l: real,
    pub cyl1l: real,
    #[doc = "@}*/\n//! Coupling constant (number of swap attempt steps)"]
    pub nAverage: ::std::os::raw::c_int,
    #[doc = "! Ion counts may deviate from the requested values by +-threshold before a swap is done"]
    pub threshold: real,
    #[doc = "! Offset of the swap layer (='bulk') with respect to the compartment-defining layers"]
    pub bulkOffset: [u32; 2usize],
    #[doc = "! Number of groups to be controlled"]
    pub ngrp: ::std::os::raw::c_int,
    #[doc = "! All swap groups, including split and solvent"]
    pub grp: *mut t_swapGroup,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PressureCouplingOptions {
    #[doc = "! Pressure coupling algorithm"]
    pub epc: PressureCoupling,
    #[doc = "! Pressure coupling isotropy"]
    pub epct: PressureCouplingType,
    #[doc = "! Interval in steps for pressure coupling"]
    pub nstpcouple: ::std::os::raw::c_int,
    #[doc = "! Pressure coupling time (ps)"]
    pub tau_p: real,
    #[doc = "! Reference pressure (kJ/(mol nm^3))"]
    pub ref_p: tensor,
    #[doc = "! Compressibility ((mol nm^3)/kJ)"]
    pub compress: tensor,
    #[doc = "! How to scale absolute reference coordinates"]
    pub refcoord_scaling: RefCoordScaling,
}
#[repr(C)]
#[derive(Debug)]
pub struct t_inputrec {
    #[doc = "! The tpx version number this inputrec was read from, -1 when not read from tpr"]
    pub tpxFileVersion: ::std::os::raw::c_int,
    #[doc = "! Integration method"]
    pub eI: IntegrationAlgorithm,
    #[doc = "! Number of steps to be taken"]
    pub nsteps: i64,
    #[doc = "! Used in checkpointing to separate chunks"]
    pub simulation_part: ::std::os::raw::c_int,
    #[doc = "! Start at a stepcount >0 (used w. convert-tpr)"]
    pub init_step: i64,
    #[doc = "! Frequency of energy calc. and T/P coupl. upd."]
    pub nstcalcenergy: ::std::os::raw::c_int,
    #[doc = "! Group or verlet cutoffs"]
    pub cutoff_scheme: CutoffScheme,
    #[doc = "! Number of steps before pairlist is generated"]
    pub nstlist: ::std::os::raw::c_int,
    #[doc = "! Number of steps after which center of mass motion is removed"]
    pub nstcomm: ::std::os::raw::c_int,
    #[doc = "! Center of mass motion removal algorithm"]
    pub comm_mode: ComRemovalAlgorithm,
    #[doc = "! Number of steps after which print to logfile"]
    pub nstlog: ::std::os::raw::c_int,
    #[doc = "! Number of steps after which X is output"]
    pub nstxout: ::std::os::raw::c_int,
    #[doc = "! Number of steps after which V is output"]
    pub nstvout: ::std::os::raw::c_int,
    #[doc = "! Number of steps after which F is output"]
    pub nstfout: ::std::os::raw::c_int,
    #[doc = "! Number of steps after which energies printed"]
    pub nstenergy: ::std::os::raw::c_int,
    #[doc = "! Number of steps after which compressed trj (.xtc,.tng) is output"]
    pub nstxout_compressed: ::std::os::raw::c_int,
    #[doc = "! Initial time (ps)"]
    pub init_t: f64,
    #[doc = "! Time step (ps)"]
    pub delta_t: f64,
    #[doc = "! Whether we use multiple time stepping"]
    pub useMts: bool,
    #[doc = "! The multiple time stepping levels"]
    pub mtsLevels: [u64; 3usize],
    #[doc = "! Precision of x in compressed trajectory file"]
    pub x_compression_precision: real,
    #[doc = "! Requested fourier_spacing, when nk? not set"]
    pub fourier_spacing: real,
    #[doc = "! Number of k vectors in x dimension for fourier methods for long range electrost."]
    pub nkx: ::std::os::raw::c_int,
    #[doc = "! Number of k vectors in y dimension for fourier methods for long range electrost."]
    pub nky: ::std::os::raw::c_int,
    #[doc = "! Number of k vectors in z dimension for fourier methods for long range electrost."]
    pub nkz: ::std::os::raw::c_int,
    #[doc = "! Interpolation order for PME"]
    pub pme_order: ::std::os::raw::c_int,
    #[doc = "! Real space tolerance for Ewald, determines the real/reciprocal space relative weight"]
    pub ewald_rtol: real,
    #[doc = "! Real space tolerance for LJ-Ewald"]
    pub ewald_rtol_lj: real,
    #[doc = "! Normal/3D ewald, or pseudo-2D LR corrections"]
    pub ewald_geometry: EwaldGeometry,
    #[doc = "! Epsilon for PME dipole correction"]
    pub epsilon_surface: real,
    #[doc = "! Type of combination rule in LJ-PME"]
    pub ljpme_combination_rule: LongRangeVdW,
    #[doc = "! Type of periodic boundary conditions"]
    pub pbcType: PbcType,
    #[doc = "! Periodic molecules"]
    pub bPeriodicMols: bool,
    #[doc = "! Continuation run: starting state is correct (ie. constrained)"]
    pub bContinuation: bool,
    #[doc = "! Whether and what kind of ensemble temperature we have for the system"]
    pub ensembleTemperatureSetting: EnsembleTemperatureSetting,
    #[doc = "! The ensemble temperature of the system, see ensembleTemperatureSetting for validity"]
    pub ensembleTemperature: real,
    #[doc = "! Temperature coupling"]
    pub etc: TemperatureCoupling,
    #[doc = "! Interval in steps for temperature coupling"]
    pub nsttcouple: ::std::os::raw::c_int,
    #[doc = "! Whether to print nose-hoover chains"]
    pub bPrintNHChains: bool,
    #[doc = "! Pressure coupling"]
    pub pressureCouplingOptions: PressureCouplingOptions,
    #[doc = "! The COM of the posres atoms"]
    pub posres_com: rvec,
    #[doc = "! The B-state COM of the posres atoms"]
    pub posres_comB: rvec,
    #[doc = "! Random seed for Andersen thermostat (obsolete)"]
    pub andersen_seed: ::std::os::raw::c_int,
    #[doc = "! Per atom pair energy drift tolerance (kJ/mol/ps/atom) for list buffer"]
    pub verletbuf_tol: real,
    #[doc = "! Short range pairlist cut-off (nm)"]
    pub rlist: real,
    #[doc = "! Radius for test particle insertion"]
    pub rtpi: real,
    #[doc = "! Type of electrostatics treatment"]
    pub coulombtype: CoulombInteractionType,
    #[doc = "! Modify the Coulomb interaction"]
    pub coulomb_modifier: InteractionModifiers,
    #[doc = "! Coulomb switch range start (nm)"]
    pub rcoulomb_switch: real,
    #[doc = "! Coulomb cutoff (nm)"]
    pub rcoulomb: real,
    #[doc = "! Relative dielectric constant"]
    pub epsilon_r: real,
    #[doc = "! Relative dielectric constant of the RF"]
    pub epsilon_rf: real,
    #[doc = "! Always false (no longer supported)"]
    pub implicit_solvent: bool,
    #[doc = "! Type of Van der Waals treatment"]
    pub vdwtype: VanDerWaalsType,
    #[doc = "! Modify the Van der Waals interaction"]
    pub vdw_modifier: InteractionModifiers,
    #[doc = "! Van der Waals switch range start (nm)"]
    pub rvdw_switch: real,
    #[doc = "! Van der Waals cutoff (nm)"]
    pub rvdw: real,
    #[doc = "! Perform Long range dispersion corrections"]
    pub eDispCorr: DispersionCorrectionType,
    #[doc = "! Extension of the table beyond the cut-off, as well as the table length for 1-4 interac."]
    pub tabext: real,
    #[doc = "! Tolerance for shake"]
    pub shake_tol: real,
    #[doc = "! Free energy calculations"]
    pub efep: FreeEnergyPerturbationType,
    #[doc = "! Data for the FEP state"]
    pub fepvals: u64,
    #[doc = "! Whether to do simulated tempering"]
    pub bSimTemp: bool,
    #[doc = "! Variables for simulated tempering"]
    pub simtempvals: u64,
    #[doc = "! Whether expanded ensembles are used"]
    pub bExpanded: bool,
    #[doc = "! Expanded ensemble parameters"]
    pub expandedvals: u64,
    #[doc = "! Type of distance restraining"]
    pub eDisre: DistanceRestraintRefinement,
    #[doc = "! Force constant for time averaged distance restraints"]
    pub dr_fc: real,
    #[doc = "! Type of weighting of pairs in one restraints"]
    pub eDisreWeighting: DistanceRestraintWeighting,
    #[doc = "! Use combination of time averaged and instantaneous violations"]
    pub bDisreMixed: bool,
    #[doc = "! Frequency of writing pair distances to enx"]
    pub nstdisreout: ::std::os::raw::c_int,
    #[doc = "! Time constant for memory function in disres"]
    pub dr_tau: real,
    #[doc = "! Force constant for orientational restraints"]
    pub orires_fc: real,
    #[doc = "! Time constant for memory function in orires"]
    pub orires_tau: real,
    #[doc = "! Frequency of writing tr(SD) to energy output"]
    pub nstorireout: ::std::os::raw::c_int,
    #[doc = "! The stepsize for updating"]
    pub em_stepsize: real,
    #[doc = "! The tolerance"]
    pub em_tol: real,
    #[doc = "! Number of iterations for convergence of steepest descent in relax_shells"]
    pub niter: ::std::os::raw::c_int,
    #[doc = "! Stepsize for directional minimization in relax_shells"]
    pub fc_stepsize: real,
    #[doc = "! Number of steps after which a steepest descents step is done while doing cg"]
    pub nstcgsteep: ::std::os::raw::c_int,
    #[doc = "! Number of corrections to the Hessian to keep"]
    pub nbfgscorr: ::std::os::raw::c_int,
    #[doc = "! Type of constraint algorithm"]
    pub eConstrAlg: ConstraintAlgorithm,
    #[doc = "! Order of the LINCS Projection Algorithm"]
    pub nProjOrder: ::std::os::raw::c_int,
    #[doc = "! Warn if any bond rotates more than this many degrees"]
    pub LincsWarnAngle: real,
    #[doc = "! Number of iterations in the final LINCS step"]
    pub nLincsIter: ::std::os::raw::c_int,
    #[doc = "! Use successive overrelaxation for shake"]
    pub bShakeSOR: bool,
    #[doc = "! Friction coefficient for BD (amu/ps)"]
    pub bd_fric: real,
    #[doc = "! Random seed for SD and BD"]
    pub ld_seed: i64,
    #[doc = "! The number of walls"]
    pub nwall: ::std::os::raw::c_int,
    #[doc = "! The type of walls"]
    pub wall_type: WallType,
    #[doc = "! The potentail is linear for r<=wall_r_linpot"]
    pub wall_r_linpot: real,
    #[doc = "! The atom type for walls"]
    pub wall_atomtype: [::std::os::raw::c_int; 2usize],
    #[doc = "! Number density for walls"]
    pub wall_density: [real; 2usize],
    #[doc = "! Scaling factor for the box for Ewald"]
    pub wall_ewald_zfac: real,
    #[doc = "! Do we do COM pulling?"]
    pub bPull: bool,
    #[doc = "! The data for center of mass pulling"]
    pub pull: u64,
    #[doc = "! Whether to use AWH biasing for PMF calculations"]
    pub bDoAwh: bool,
    #[doc = "! AWH biasing parameters"]
    pub awhParams: u64,
    #[doc = "! Whether to calculate enforced rotation potential(s)"]
    pub bRot: bool,
    #[doc = "! The data for enforced rotation potentials"]
    pub rot: u64,
    #[doc = "! Whether to do ion/water position exchanges (CompEL)"]
    pub eSwapCoords: SwapType,
    #[doc = "! Swap data structure."]
    pub swap: *mut t_swapcoords,
    #[doc = "! Whether the tpr makes an interactive MD session possible."]
    pub bIMD: bool,
    #[doc = "! Interactive molecular dynamics"]
    pub imd: *mut t_IMD,
    #[doc = "! Acceleration for viscosity calculation"]
    pub cos_accel: real,
    #[doc = "! Triclinic deformation velocities (nm/ps)"]
    pub deform: tensor,
    #[doc = " \\brief User determined parameters */\n/**@{"]
    pub userint1: ::std::os::raw::c_int,
    pub userint2: ::std::os::raw::c_int,
    pub userint3: ::std::os::raw::c_int,
    pub userint4: ::std::os::raw::c_int,
    pub userreal1: real,
    pub userreal2: real,
    pub userreal3: real,
    pub userreal4: real,
    #[doc = "@}*/\n//! Group options"]
    pub opts: t_grpopts,
    #[doc = "! QM/MM calculation"]
    pub bQMMM: bool,
    #[doc = "! Whether AdResS is enabled - always false if a valid .tpr was read"]
    pub bAdress: bool,
    #[doc = "! Whether twin-range scheme is active - always false if a valid .tpr was read"]
    pub useTwinRange: bool,
    #[doc = "! Whether we have constant acceleration"]
    pub useConstantAcceleration: bool,
    #[doc = "! KVT object that contains input parameters converted to the new style."]
    pub params: *mut gmx_KeyValueTreeObject,
    #[doc = "! KVT for storing simulation parameters that are not part of the mdp file."]
    pub internalParameters: u64,
}
extern "C" {
    #[link_name = "\u{1}_ZN10t_inputrecC1Ev"]
    pub fn t_inputrec_t_inputrec(this: *mut t_inputrec);
}
extern "C" {
    #[link_name = "\u{1}_ZN10t_inputrecD1Ev"]
    pub fn t_inputrec_t_inputrec_destructor(this: *mut t_inputrec);
}
impl t_inputrec {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        t_inputrec_t_inputrec(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        t_inputrec_t_inputrec_destructor(self)
    }
}
#[doc = " \\libinternal \\brief History information for NMR distance and orientation restraints\n\n Often this is only used for reporting observables, and thus should not\n actually be part of the microstate. But with time-dependent restraining\n they are actually part of the (non-Markovian) microstate.\n \\todo Rename this with a more descriptive name."]
#[repr(C)]
#[derive(Debug)]
pub struct history_t {
    #[doc = "!< The scaling factor for initializing the time av."]
    pub disre_initf: real,
    #[doc = "!< The r^-3 time averaged pair distances"]
    pub disre_rm3tav: [u64; 3usize],
    #[doc = "!< The scaling factor for initializing the time av."]
    pub orire_initf: real,
    #[doc = "!< The time averaged orientation tensors"]
    pub orire_Dtav: [u64; 3usize],
}
extern "C" {
    #[link_name = "\u{1}_ZN9history_tC1Ev"]
    pub fn history_t_history_t(this: *mut history_t);
}
impl history_t {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        history_t_history_t(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[doc = " \\libinternal \\brief Struct used for checkpointing only\n\n This struct would not be required with unlimited precision.\n But because of limited precision, the COM motion removal implementation\n can cause the kinetic energy in the MD loop to differ by a few bits from\n the kinetic energy one would determine from state.v."]
#[repr(C)]
#[derive(Debug)]
pub struct ekinstate_t {
    #[doc = "!< Test if all data is up to date"]
    pub bUpToDate: bool,
    #[doc = "!< The number of tensors"]
    pub ekin_n: ::std::os::raw::c_int,
    #[doc = "!< Half step Ekin, size \\p ekin_n"]
    pub ekinh: *mut tensor,
    #[doc = "!< Full step Ekin, size \\p ekin_n"]
    pub ekinf: *mut tensor,
    #[doc = "!< Half step Ekin of the previous step, size \\p ekin_n"]
    pub ekinh_old: *mut tensor,
    #[doc = "!< Total kinetic energy"]
    pub ekin_total: tensor,
    #[doc = "!< Nose-Hoover Ekin scaling factors for full step Ekin"]
    pub ekinscalef_nhc: [u64; 3usize],
    #[doc = "!< Nose-Hoover Ekin scaling factors for half step Ekin"]
    pub ekinscaleh_nhc: [u64; 3usize],
    #[doc = "!< Nose-Hoover velocity scaling factors"]
    pub vscale_nhc: [u64; 3usize],
    #[doc = "!< dEkin/dlambda, with free-energy"]
    pub dekindl: real,
    #[doc = "!< Cosine(z) component of the momentum, for viscosity calculations"]
    pub mvcos: real,
    #[doc = " \\brief Whether KE terms have been read from the checkpoint.\n\n Only used for managing whether the call to compute_globals\n before we enter the MD loop should compute these quantities\n fresh, or not."]
    pub hasReadEkinState: bool,
}
extern "C" {
    #[link_name = "\u{1}_ZN11ekinstate_tC1Ev"]
    pub fn ekinstate_t_ekinstate_t(this: *mut ekinstate_t);
}
impl ekinstate_t {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ekinstate_t_ekinstate_t(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[doc = " \\brief Free-energy sampling history struct\n\n \\todo Split out into microstate and observables history."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct df_history_t {
    #[doc = "!< total number of lambda states - for history"]
    pub nlambda: ::std::os::raw::c_int,
    #[doc = "!< Have we reached equilibration"]
    pub bEquil: bool,
    #[doc = "!< number of points observed at each lambda"]
    pub n_at_lam: *mut ::std::os::raw::c_int,
    #[doc = "!< histogram for WL flatness determination"]
    pub wl_histo: *mut real,
    #[doc = "!< current wang-landau delta"]
    pub wl_delta: real,
    #[doc = "!< weights of the states"]
    pub sum_weights: *mut real,
    #[doc = "!< free energies of the states -- not actually used for weighting, but informational"]
    pub sum_dg: *mut real,
    #[doc = "!< corrections to weights for minimum variance"]
    pub sum_minvar: *mut real,
    #[doc = "!< variances of the states"]
    pub sum_variance: *mut real,
    #[doc = "!< accumulated bennett weights for n+1"]
    pub accum_p: *mut *mut real,
    #[doc = "!< accumulated bennett weights for n-1"]
    pub accum_m: *mut *mut real,
    #[doc = "!< accumulated squared bennett weights for n+1"]
    pub accum_p2: *mut *mut real,
    #[doc = "!< accumulated squared bennett weights for n-1"]
    pub accum_m2: *mut *mut real,
    #[doc = "!< transition matrix"]
    pub Tij: *mut *mut real,
    #[doc = "!< Empirical transition matrix"]
    pub Tij_empirical: *mut *mut real,
}
#[doc = " \\brief The microstate of the system\n\n The global state will contain complete data for all used entries.\n The local state with domain decomposition will have partial entries\n for which \\p stateEntryIsAtomProperty() is true. Some entries that\n are used in the global state might not be present in the local state.\n \\todo Move pure observables history to ObservablesHistory."]
#[repr(C)]
#[derive(Debug)]
pub struct t_state {
    #[doc = "!< Number of atoms, local + non-local; this is the size of \\p x, \\p v and \\p cg_p, when used"]
    pub natoms: ::std::os::raw::c_int,
    #[doc = "!< The number of temperature coupling groups"]
    pub ngtc: ::std::os::raw::c_int,
    #[doc = "!< The number of NH-chains for the MTTK barostat (always 1 or 0)"]
    pub nnhpres: ::std::os::raw::c_int,
    #[doc = "!< The NH-chain length for temperature coupling and MTTK barostat"]
    pub nhchainlength: ::std::os::raw::c_int,
    #[doc = "!< Set of bit-flags telling which entries are present, see enum at the top of the file"]
    pub flags: ::std::os::raw::c_int,
    #[doc = "!< indicates which of the alchemical states we are in"]
    pub fep_state: ::std::os::raw::c_int,
    #[doc = "!< Free-energy lambda vector"]
    pub lambda: [u32; 7usize],
    #[doc = "!< Matrix of box vectors"]
    pub box_: matrix,
    #[doc = "! Relative box vectors characteristic of the box shape, used to to preserve that box shape"]
    pub box_rel: matrix,
    #[doc = "!< Box velocities for Parrinello-Rahman P-coupling"]
    pub boxv: matrix,
    #[doc = "!< Pressure of the previous step for pcoupl"]
    pub pres_prev: matrix,
    #[doc = "!< Shake virial for previous step for pcoupl"]
    pub svir_prev: matrix,
    #[doc = "!< Force virial of the previous step for pcoupl"]
    pub fvir_prev: matrix,
    #[doc = "!< Nose-Hoover coordinates (ngtc)"]
    pub nosehoover_xi: [u64; 3usize],
    #[doc = "!< Nose-Hoover velocities (ngtc)"]
    pub nosehoover_vxi: [u64; 3usize],
    #[doc = "!< Pressure Nose-Hoover coordinates"]
    pub nhpres_xi: [u64; 3usize],
    #[doc = "!< Pressure Nose-Hoover velocities"]
    pub nhpres_vxi: [u64; 3usize],
    #[doc = "!< Work exterted N-H/V-rescale T-coupling (ngtc)"]
    pub therm_integral: [u64; 3usize],
    #[doc = "!< For Berendsen P-coupling conserved quantity"]
    pub baros_integral: f64,
    #[doc = "!< Trotter based isotropic P-coupling"]
    pub veta: real,
    #[doc = "!< Initial volume,required for computing MTTK conserved quantity"]
    pub vol0: real,
    #[doc = "!< The coordinates (natoms)"]
    pub x: gmx_PaddedVector,
    #[doc = "!< The velocities (natoms)"]
    pub v: gmx_PaddedVector,
    #[doc = "!< p vector for conjugate gradient minimization"]
    pub cg_p: gmx_PaddedVector,
    #[doc = "!< The state of the kinetic energy"]
    pub ekinstate: ekinstate_t,
    #[doc = "!< Time history for restraints"]
    pub hist: history_t,
    #[doc = "!< Free-energy history for free energy analysis"]
    pub dfhist: *mut df_history_t,
    #[doc = "!< Accelerated weight histogram history"]
    pub awhHistory: [u64; 2usize],
    #[doc = "!< The DD partitioning count for this state"]
    pub ddp_count: ::std::os::raw::c_int,
    #[doc = "!< The DD partitioning count for index_gl"]
    pub ddp_count_cg_gl: ::std::os::raw::c_int,
    #[doc = "!< The global cg number of the local cgs"]
    pub cg_gl: [u64; 3usize],
    #[doc = "!< The COM of the previous step of each pull group"]
    pub pull_com_prev_step: [u64; 3usize],
}
extern "C" {
    #[link_name = "\u{1}_ZN7t_stateC1Ev"]
    pub fn t_state_t_state(this: *mut t_state);
}
impl t_state {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        t_state_t_state(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[doc = " \\libinternal \\brief\n Legacy symbol table entry as linked list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_symbuf {
    #[doc = "! Number of entries in this item"]
    pub bufsize: ::std::os::raw::c_int,
    #[doc = "! Storage for strings in this item."]
    pub buf: *mut *mut ::std::os::raw::c_char,
    #[doc = "! Next item in linked list."]
    pub next: *mut t_symbuf,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_symtab {
    #[doc = "! Total number of entries stored."]
    pub nr: ::std::os::raw::c_int,
    #[doc = "! First item in linked list of storage elements."]
    pub symbuf: *mut t_symbuf,
}
pub const ParticleType_Atom: ParticleType = 0;
pub const ParticleType_Nucleus: ParticleType = 1;
pub const ParticleType_Shell: ParticleType = 2;
pub const ParticleType_Bond: ParticleType = 3;
pub const ParticleType_VSite: ParticleType = 4;
pub const ParticleType_Count: ParticleType = 5;
pub type ParticleType = ::std::os::raw::c_int;
pub const PdbRecordType_Atom: PdbRecordType = 0;
pub const PdbRecordType_Hetatm: PdbRecordType = 1;
pub const PdbRecordType_Anisou: PdbRecordType = 2;
pub const PdbRecordType_Cryst1: PdbRecordType = 3;
pub const PdbRecordType_Compound: PdbRecordType = 4;
pub const PdbRecordType_Model: PdbRecordType = 5;
pub const PdbRecordType_EndModel: PdbRecordType = 6;
pub const PdbRecordType_Ter: PdbRecordType = 7;
pub const PdbRecordType_Header: PdbRecordType = 8;
pub const PdbRecordType_Title: PdbRecordType = 9;
pub const PdbRecordType_Remark: PdbRecordType = 10;
pub const PdbRecordType_Conect: PdbRecordType = 11;
pub const PdbRecordType_Count: PdbRecordType = 12;
pub type PdbRecordType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_atom {
    pub m: real,
    pub q: real,
    pub mB: real,
    pub qB: real,
    pub type_: ::std::os::raw::c_ushort,
    pub typeB: ::std::os::raw::c_ushort,
    pub ptype: ParticleType,
    pub resind: ::std::os::raw::c_int,
    pub atomnumber: ::std::os::raw::c_int,
    pub elem: [::std::os::raw::c_char; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_resinfo {
    pub name: *mut *mut ::std::os::raw::c_char,
    pub nr: ::std::os::raw::c_int,
    pub ic: ::std::os::raw::c_uchar,
    pub chainnum: ::std::os::raw::c_int,
    pub chainid: ::std::os::raw::c_char,
    pub rtp: *mut *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_pdbinfo {
    pub type_: PdbRecordType,
    pub atomnr: ::std::os::raw::c_int,
    pub altloc: ::std::os::raw::c_char,
    pub atomnm: [::std::os::raw::c_char; 6usize],
    pub occup: real,
    pub bfac: real,
    pub bAnisotropic: bool,
    pub uij: [::std::os::raw::c_int; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_atoms {
    pub nr: ::std::os::raw::c_int,
    pub atom: *mut t_atom,
    pub atomname: *mut *mut *mut ::std::os::raw::c_char,
    pub atomtype: *mut *mut *mut ::std::os::raw::c_char,
    pub atomtypeB: *mut *mut *mut ::std::os::raw::c_char,
    pub nres: ::std::os::raw::c_int,
    pub resinfo: *mut t_resinfo,
    pub pdbinfo: *mut t_pdbinfo,
    pub haveMass: bool,
    pub haveCharge: bool,
    pub haveType: bool,
    pub haveBState: bool,
    pub havePdbInfo: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_block {
    pub nr: ::std::os::raw::c_int,
    pub index: *mut ::std::os::raw::c_int,
    pub nalloc_index: ::std::os::raw::c_int,
}
pub type t_iatom = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union t_iparams {
    pub bham: t_iparams__bindgen_ty_1,
    pub harmonic: t_iparams__bindgen_ty_2,
    pub linangle: t_iparams__bindgen_ty_3,
    pub restraint: t_iparams__bindgen_ty_4,
    pub cubic: t_iparams__bindgen_ty_5,
    pub fene: t_iparams__bindgen_ty_6,
    pub cross_bb: t_iparams__bindgen_ty_7,
    pub cross_ba: t_iparams__bindgen_ty_8,
    pub u_b: t_iparams__bindgen_ty_9,
    pub qangle: t_iparams__bindgen_ty_10,
    pub polarize: t_iparams__bindgen_ty_11,
    pub anharm_polarize: t_iparams__bindgen_ty_12,
    pub wpol: t_iparams__bindgen_ty_13,
    pub thole: t_iparams__bindgen_ty_14,
    pub lj: t_iparams__bindgen_ty_15,
    pub lj14: t_iparams__bindgen_ty_16,
    pub ljc14: t_iparams__bindgen_ty_17,
    pub ljcnb: t_iparams__bindgen_ty_18,
    pub pdihs: t_iparams__bindgen_ty_19,
    pub constr: t_iparams__bindgen_ty_20,
    pub settle: t_iparams__bindgen_ty_21,
    pub morse: t_iparams__bindgen_ty_22,
    pub posres: t_iparams__bindgen_ty_23,
    pub fbposres: t_iparams__bindgen_ty_24,
    pub rbdihs: t_iparams__bindgen_ty_25,
    pub cbtdihs: t_iparams__bindgen_ty_26,
    pub vsite: t_iparams__bindgen_ty_27,
    pub vsiten: t_iparams__bindgen_ty_28,
    pub disres: t_iparams__bindgen_ty_29,
    pub dihres: t_iparams__bindgen_ty_30,
    pub orires: t_iparams__bindgen_ty_31,
    pub tab: t_iparams__bindgen_ty_32,
    pub cmap: t_iparams__bindgen_ty_33,
    pub generic: t_iparams__bindgen_ty_34,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_1 {
    pub a: real,
    pub b: real,
    pub c: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_2 {
    pub rA: real,
    pub krA: real,
    pub rB: real,
    pub krB: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_3 {
    pub klinA: real,
    pub aA: real,
    pub klinB: real,
    pub aB: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_4 {
    pub lowA: real,
    pub up1A: real,
    pub up2A: real,
    pub kA: real,
    pub lowB: real,
    pub up1B: real,
    pub up2B: real,
    pub kB: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_5 {
    pub b0: real,
    pub kb: real,
    pub kcub: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_6 {
    pub bm: real,
    pub kb: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_7 {
    pub r1e: real,
    pub r2e: real,
    pub krr: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_8 {
    pub r1e: real,
    pub r2e: real,
    pub r3e: real,
    pub krt: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_9 {
    pub thetaA: real,
    pub kthetaA: real,
    pub r13A: real,
    pub kUBA: real,
    pub thetaB: real,
    pub kthetaB: real,
    pub r13B: real,
    pub kUBB: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_10 {
    pub theta: real,
    pub c: [real; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_11 {
    pub alpha: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_12 {
    pub alpha: real,
    pub drcut: real,
    pub khyp: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_13 {
    pub al_x: real,
    pub al_y: real,
    pub al_z: real,
    pub rOH: real,
    pub rHH: real,
    pub rOD: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_14 {
    pub a: real,
    pub alpha1: real,
    pub alpha2: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_15 {
    pub c6: real,
    pub c12: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_16 {
    pub c6A: real,
    pub c12A: real,
    pub c6B: real,
    pub c12B: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_17 {
    pub fqq: real,
    pub qi: real,
    pub qj: real,
    pub c6: real,
    pub c12: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_18 {
    pub qi: real,
    pub qj: real,
    pub c6: real,
    pub c12: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_19 {
    pub phiA: real,
    pub cpA: real,
    pub mult: ::std::os::raw::c_int,
    pub phiB: real,
    pub cpB: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_20 {
    pub dA: real,
    pub dB: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_21 {
    pub doh: real,
    pub dhh: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_22 {
    pub b0A: real,
    pub cbA: real,
    pub betaA: real,
    pub b0B: real,
    pub cbB: real,
    pub betaB: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_23 {
    pub pos0A: [real; 3usize],
    pub fcA: [real; 3usize],
    pub pos0B: [real; 3usize],
    pub fcB: [real; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_24 {
    pub pos0: [real; 3usize],
    pub r: real,
    pub k: real,
    pub geom: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_25 {
    pub rbcA: [real; 6usize],
    pub rbcB: [real; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_26 {
    pub cbtcA: [real; 6usize],
    pub cbtcB: [real; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_27 {
    pub a: real,
    pub b: real,
    pub c: real,
    pub d: real,
    pub e: real,
    pub f: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_28 {
    pub n: ::std::os::raw::c_int,
    pub a: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_29 {
    pub low: real,
    pub up1: real,
    pub up2: real,
    pub kfac: real,
    pub type_: ::std::os::raw::c_int,
    pub label: ::std::os::raw::c_int,
    pub npair: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_30 {
    pub phiA: real,
    pub dphiA: real,
    pub kfacA: real,
    pub phiB: real,
    pub dphiB: real,
    pub kfacB: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_31 {
    pub ex: ::std::os::raw::c_int,
    pub power: ::std::os::raw::c_int,
    pub label: ::std::os::raw::c_int,
    pub c: real,
    pub obs: real,
    pub kfac: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_32 {
    pub table: ::std::os::raw::c_int,
    pub kA: real,
    pub kB: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_33 {
    pub cmapA: ::std::os::raw::c_int,
    pub cmapB: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_34 {
    pub buf: [real; 12usize],
}
pub type t_functype = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_ilist {
    pub nr: ::std::os::raw::c_int,
    pub iatoms: *mut t_iatom,
    pub nalloc: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_idef {
    pub ntypes: ::std::os::raw::c_int,
    pub atnr: ::std::os::raw::c_int,
    pub functype: *mut t_functype,
    pub iparams: *mut t_iparams,
    pub fudgeQQ: real,
    pub iparams_posres: *mut t_iparams,
    pub iparams_fbposres: *mut t_iparams,
    pub il: [t_ilist; 94usize],
    pub ilsort: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_topology {
    pub name: *mut *mut ::std::os::raw::c_char,
    pub idef: t_idef,
    pub atoms: t_atoms,
    pub mols: t_block,
    pub bIntermolecularInteractions: bool,
    pub symtab: t_symtab,
}
#[repr(C)]
#[derive(Debug)]
pub struct TprHelper {
    pub top: t_topology,
    pub state: t_state,
    pub ir: t_inputrec,
}
extern "C" {
    #[link_name = "\u{1}_ZN9TprHelper7get_topEv"]
    pub fn TprHelper_get_top(this: *mut TprHelper) -> *mut t_topology;
}
extern "C" {
    #[link_name = "\u{1}_ZN9TprHelper12get_atom_xyzEi"]
    pub fn TprHelper_get_atom_xyz(this: *mut TprHelper, ind: ::std::os::raw::c_int) -> *mut f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN9TprHelper7get_boxEv"]
    pub fn TprHelper_get_box(this: *mut TprHelper) -> *mut f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN9TprHelper12get_atomnameEi"]
    pub fn TprHelper_get_atomname(
        this: *mut TprHelper,
        ind: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN9TprHelperC1EPKc"]
    pub fn TprHelper_TprHelper(this: *mut TprHelper, fname: *const ::std::os::raw::c_char);
}
impl TprHelper {
    #[inline]
    pub unsafe fn get_top(&mut self) -> *mut t_topology {
        TprHelper_get_top(self)
    }
    #[inline]
    pub unsafe fn get_atom_xyz(&mut self, ind: ::std::os::raw::c_int) -> *mut f32 {
        TprHelper_get_atom_xyz(self, ind)
    }
    #[inline]
    pub unsafe fn get_box(&mut self) -> *mut f32 {
        TprHelper_get_box(self)
    }
    #[inline]
    pub unsafe fn get_atomname(
        &mut self,
        ind: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char {
        TprHelper_get_atomname(self, ind)
    }
    #[inline]
    pub unsafe fn new(fname: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TprHelper_TprHelper(__bindgen_tmp.as_mut_ptr(), fname);
        __bindgen_tmp.assume_init()
    }
}
