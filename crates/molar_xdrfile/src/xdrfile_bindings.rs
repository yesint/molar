/* automatically generated by rust-bindgen 0.66.1 */

pub const DIM: u32 = 3;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XDRFILE {
    _unused: [u8; 0],
}
pub const exdrOK: _bindgen_ty_1 = 0;
pub const exdrHEADER: _bindgen_ty_1 = 1;
pub const exdrSTRING: _bindgen_ty_1 = 2;
pub const exdrDOUBLE: _bindgen_ty_1 = 3;
pub const exdrINT: _bindgen_ty_1 = 4;
pub const exdrFLOAT: _bindgen_ty_1 = 5;
pub const exdrUINT: _bindgen_ty_1 = 6;
pub const exdr3DX: _bindgen_ty_1 = 7;
pub const exdrCLOSE: _bindgen_ty_1 = 8;
pub const exdrMAGIC: _bindgen_ty_1 = 9;
pub const exdrNOMEM: _bindgen_ty_1 = 10;
pub const exdrENDOFFILE: _bindgen_ty_1 = 11;
pub const exdrFILENOTFOUND: _bindgen_ty_1 = 12;
pub const exdrNR: _bindgen_ty_1 = 13;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
extern "C" {
    pub static mut exdr_message: [*mut ::std::os::raw::c_char; 13usize];
}
pub type matrix = [[f32; 3usize]; 3usize];
pub type rvec = [f32; 3usize];
pub type mybool = ::std::os::raw::c_int;
extern "C" {
    #[doc = " \\brief Open a portable binary file, just like fopen()\n\n  Use this routine much like calls to the standard library function\n  fopen(). The only difference is that the returned pointer should only\n  be used with routines defined in this header.\n\n  \\param path  Full or relative path (including name) of the file\n  \\param mode  \"r\" for reading, \"w\" for writing, \"a\" for append.\n\n  \\return Pointer to abstract xdr file datatype, or NULL if an error occurs.\n"]
    pub fn xdrfile_open(
        path: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut XDRFILE;
}
extern "C" {
    #[doc = " \\brief Close a previously opened portable binary file, just like fclose()\n\n  Use this routine much like calls to the standard library function\n  fopen(). The only difference is that it is used for an XDRFILE handle\n  instead of a FILE handle.\n\n  \\param xfp  Pointer to an abstract XDRFILE datatype\n\n  \\return     0 on success, non-zero on error."]
    pub fn xdrfile_close(xfp: *mut XDRFILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Read one or more \\a char type variable(s)\n\n  \\param ptr    Pointer to memory where data should be written\n  \\param ndata  Number of characters to read\n  \\param xfp    Handle to portable binary file, created with xdrfile_open()\n\n  \\return       Number of characters read"]
    pub fn xdrfile_read_char(
        ptr: *mut ::std::os::raw::c_char,
        ndata: ::std::os::raw::c_int,
        xfp: *mut XDRFILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Write one or more \\a characters type variable(s)\n\n  \\param ptr    Pointer to memory where data should be read\n  \\param ndata  Number of characters to write.\n  \\param xfp    Handle to portable binary file, created with xdrfile_open()\n\n  \\return       Number of characters written"]
    pub fn xdrfile_write_char(
        ptr: *mut ::std::os::raw::c_char,
        ndata: ::std::os::raw::c_int,
        xfp: *mut XDRFILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Read one or more \\a unsigned \\a char type variable(s)\n\n  \\param ptr    Pointer to memory where data should be written\n  \\param ndata  Number of unsigned characters to read\n  \\param xfp    Handle to portable binary file, created with xdrfile_open()\n\n  \\return       Number of unsigned characters read"]
    pub fn xdrfile_read_uchar(
        ptr: *mut ::std::os::raw::c_uchar,
        ndata: ::std::os::raw::c_int,
        xfp: *mut XDRFILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Write one or more \\a unsigned \\a characters type variable(s)\n\n  \\param ptr    Pointer to memory where data should be read\n  \\param ndata  Number of unsigned characters to write.\n  \\param xfp    Handle to portable binary file, created with xdrfile_open()\n\n  \\return       Number of unsigned characters written"]
    pub fn xdrfile_write_uchar(
        ptr: *mut ::std::os::raw::c_uchar,
        ndata: ::std::os::raw::c_int,
        xfp: *mut XDRFILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Read one or more \\a short type variable(s)\n\n  \\param ptr    Pointer to memory where data should be written\n  \\param ndata  Number of shorts to read\n  \\param xfp    Handle to portable binary file, created with xdrfile_open()\n\n  \\return       Number of shorts read"]
    pub fn xdrfile_read_short(
        ptr: *mut ::std::os::raw::c_short,
        ndata: ::std::os::raw::c_int,
        xfp: *mut XDRFILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Write one or more \\a short type variable(s)\n\n  \\param ptr    Pointer to memory where data should be read\n  \\param ndata  Number of shorts to write.\n  \\param xfp    Handle to portable binary file, created with xdrfile_open()\n\n  \\return       Number of shorts written"]
    pub fn xdrfile_write_short(
        ptr: *mut ::std::os::raw::c_short,
        ndata: ::std::os::raw::c_int,
        xfp: *mut XDRFILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Read one or more \\a unsigned \\a short type variable(s)\n\n  \\param ptr    Pointer to memory where data should be written\n  \\param ndata  Number of unsigned shorts to read\n  \\param xfp    Handle to portable binary file, created with xdrfile_open()\n\n  \\return       Number of unsigned shorts read"]
    pub fn xdrfile_read_ushort(
        ptr: *mut ::std::os::raw::c_ushort,
        ndata: ::std::os::raw::c_int,
        xfp: *mut XDRFILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Write one or more \\a unsigned \\a short type variable(s)\n\n  \\param ptr    Pointer to memory where data should be read\n  \\param ndata  Number of unsigned shorts to write.\n  \\param xfp    Handle to portable binary file, created with xdrfile_open()\n\n  \\return       Number of unsigned shorts written"]
    pub fn xdrfile_write_ushort(
        ptr: *mut ::std::os::raw::c_ushort,
        ndata: ::std::os::raw::c_int,
        xfp: *mut XDRFILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Read one or more \\a integer type variable(s)\n\n  \\param ptr    Pointer to memory where data should be written\n  \\param ndata  Number of integers to read\n  \\param xfp    Handle to portable binary file, created with xdrfile_open()\n\n  \\return       Number of integers read\n\n  The integer data type is assumed to be less than or equal to 32 bits.\n\n  We do not provide any routines for reading/writing 64-bit integers, since\n  - Not all XDR implementations support it\n  - Not all machines have 64-bit integers\n\n  Split your 64-bit data into two 32-bit integers for portability!"]
    pub fn xdrfile_read_int(
        ptr: *mut ::std::os::raw::c_int,
        ndata: ::std::os::raw::c_int,
        xfp: *mut XDRFILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Write one or more \\a integer type variable(s)\n\n  \\param ptr    Pointer to memory where data should be read\n  \\param ndata  Number of integers to write.\n  \\param xfp    Handle to portable binary file, created with xdrfile_open()\n\n  \\return       Number of integers written\n\n  The integer data type is assumed to be less than or equal to 32 bits.\n\n  We do not provide any routines for reading/writing 64-bit integers, since\n  - Not all XDR implementations support it\n  - Not all machines have 64-bit integers\n\n  Split your 64-bit data into two 32-bit integers for portability!"]
    pub fn xdrfile_write_int(
        ptr: *mut ::std::os::raw::c_int,
        ndata: ::std::os::raw::c_int,
        xfp: *mut XDRFILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Read one or more \\a unsigned \\a integers type variable(s)\n\n  \\param ptr    Pointer to memory where data should be written\n  \\param ndata  Number of unsigned integers to read\n  \\param xfp    Handle to portable binary file, created with xdrfile_open()\n\n  \\return       Number of unsigned integers read\n\n  The integer data type is assumed to be less than or equal to 32 bits.\n\n  We do not provide any routines for reading/writing 64-bit integers, since\n  - Not all XDR implementations support it\n  - Not all machines have 64-bit integers\n\n  Split your 64-bit data into two 32-bit integers for portability!"]
    pub fn xdrfile_read_uint(
        ptr: *mut ::std::os::raw::c_uint,
        ndata: ::std::os::raw::c_int,
        xfp: *mut XDRFILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Write one or more \\a unsigned \\a integer type variable(s)\n\n  \\param ptr    Pointer to memory where data should be read\n  \\param ndata  Number of unsigned integers to write.\n  \\param xfp    Handle to portable binary file, created with xdrfile_open()\n\n  \\return       Number of unsigned integers written\n\n  The integer data type is assumed to be less than or equal to 32 bits.\n\n  We do not provide any routines for reading/writing 64-bit integers, since\n  - Not all XDR implementations support it\n  - Not all machines have 64-bit integers\n\n  Split your 64-bit data into two 32-bit integers for portability!"]
    pub fn xdrfile_write_uint(
        ptr: *mut ::std::os::raw::c_uint,
        ndata: ::std::os::raw::c_int,
        xfp: *mut XDRFILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Read one or more \\a float type variable(s)\n\n  \\param ptr    Pointer to memory where data should be written\n  \\param ndata  Number of floats to read\n  \\param xfp    Handle to portable binary file, created with xdrfile_open()\n\n  \\return       Number of floats read"]
    pub fn xdrfile_read_float(
        ptr: *mut f32,
        ndata: ::std::os::raw::c_int,
        xfp: *mut XDRFILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Write one or more \\a float type variable(s)\n\n  \\param ptr    Pointer to memory where data should be read\n  \\param ndata  Number of floats to write.\n  \\param xfp    Handle to portable binary file, created with xdrfile_open()\n\n  \\return       Number of floats written"]
    pub fn xdrfile_write_float(
        ptr: *mut f32,
        ndata: ::std::os::raw::c_int,
        xfp: *mut XDRFILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Read one or more \\a double type variable(s)\n\n  \\param ptr    Pointer to memory where data should be written\n  \\param ndata  Number of doubles to read\n  \\param xfp    Handle to portable binary file, created with xdrfile_open()\n\n  \\return       Number of doubles read"]
    pub fn xdrfile_read_double(
        ptr: *mut f64,
        ndata: ::std::os::raw::c_int,
        xfp: *mut XDRFILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Write one or more \\a double type variable(s)\n\n  \\param ptr    Pointer to memory where data should be read\n  \\param ndata  Number of double to write.\n  \\param xfp    Handle to portable binary file, created with xdrfile_open()\n\n  \\return       Number of doubles written"]
    pub fn xdrfile_write_double(
        ptr: *mut f64,
        ndata: ::std::os::raw::c_int,
        xfp: *mut XDRFILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Read a string (array of characters)\n\n  \\param ptr     Pointer to memory where data should be written\n  \\param maxlen  Maximum length of string. If no end-of-string is encountered,\n                 one byte less than this is read and end-of-string appended.\n  \\param xfp     Handle to portable binary file, created with xdrfile_open()\n\n  \\return        Number of characters read, including end-of-string"]
    pub fn xdrfile_read_string(
        ptr: *mut ::std::os::raw::c_char,
        maxlen: ::std::os::raw::c_int,
        xfp: *mut XDRFILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Write a string (array of characters)\n\n  \\param ptr     Pointer to memory where data should be read\n  \\param xfp     Handle to portable binary file, created with xdrfile_open()\n\n  \\return        Number of characters written, including end-of-string"]
    pub fn xdrfile_write_string(
        ptr: *mut ::std::os::raw::c_char,
        xfp: *mut XDRFILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Read raw bytes from file (unknown datatype)\n\n  \\param ptr     Pointer to memory where data should be written\n  \\param nbytes  Number of bytes to read. No conversion whatsoever is done.\n  \\param xfp     Handle to portable binary file, created with xdrfile_open()\n\n  \\return        Number of bytes read from file"]
    pub fn xdrfile_read_opaque(
        ptr: *mut ::std::os::raw::c_char,
        nbytes: ::std::os::raw::c_int,
        xfp: *mut XDRFILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Write raw bytes to file (unknown datatype)\n\n  \\param ptr     Pointer to memory where data should be read\n  \\param nbytes  Number of bytes to write. No conversion whatsoever is done.\n  \\param xfp     Handle to portable binary file, created with xdrfile_open()\n\n  \\return        Number of bytes written to file"]
    pub fn xdrfile_write_opaque(
        ptr: *mut ::std::os::raw::c_char,
        nbytes: ::std::os::raw::c_int,
        xfp: *mut XDRFILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Compress coordiates in a float array to XDR file\n\n  This routine will perform \\a lossy compression on the three-dimensional\n  coordinate data data specified and store it in the XDR file.\n\n  The lossy part of the compression consists of multiplying each\n  coordinate with the precision argument and then rounding to integers.\n  We suggest a default value of 1000.0, which means you are guaranteed\n  three decimals of accuracy. The only limitation is that scaled coordinates\n  must still fit in an integer variable, so if the precision is 1000.0 the\n  coordinate magnitudes must be less than +-2e6.\n\n  \\param ptr        Pointer to coordinates to compress (length 3*ncoord)\n  \\param ncoord     Number of coordinate triplets in data\n  \\param precision  Scaling factor for lossy compression. If it is <=0,\n                    the default value of 1000.0 is used.\n  \\param xfp        Handle to portably binary file\n\n  \\return           Number of coordinate triplets written.\n                    IMPORTANT: Check that this is equal to ncoord - if it is\n                    negative, an error occured. This should not happen with\n\t   \t              normal data, but if your coordinates are NaN or very\n                    large (>1e6) it is not possible to use the compression.\n\n  \\warning          The compression algorithm is not part of the XDR standard,\n                    and very complicated, so you will need this xdrfile module\n                    to read it later."]
    pub fn xdrfile_compress_coord_float(
        ptr: *mut f32,
        ncoord: ::std::os::raw::c_int,
        precision: f32,
        xfp: *mut XDRFILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Decompress coordiates from XDR file to array of floats\n\n  This routine will decompress three-dimensional coordinate data previously\n  stored in an XDR file and store it in the specified array of floats.\n\n  The precision used during the earlier compression is read from the file\n  and returned - you cannot adjust the accuracy at this stage.\n\n  \\param ptr        Pointer to coordinates to compress (length>= 3*ncoord)\n  \\param ncoord     Max number of coordinate triplets to read on input, actual\n                    number of coordinate triplets read on return. If this\n                    is smaller than the number of coordinates in the frame an\n                    error will occur.\n  \\param precision  The precision used in the previous compression will be\n                    written to this variable on return.\n  \\param xfp        Handle to portably binary file\n\n  \\return           Number of coordinate triplets read. If this is negative,\n                    an error occured.\n\n  \\warning          Since we cannot count on being able to set/get the\n                    position of large files (>2Gb), it is not possible to\n                    recover from errors by re-reading the frame if the\n                    storage area you provided was too small. To avoid this\n                    from happening, we recommend that you store the number of\n                    coordinates triplet as an integer either in a header or\n                    just before the compressed coordinate data, so you can\n                    read it first and allocated enough memory."]
    pub fn xdrfile_decompress_coord_float(
        ptr: *mut f32,
        ncoord: *mut ::std::os::raw::c_int,
        precision: *mut f32,
        xfp: *mut XDRFILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Compress coordiates in a double array to XDR file\n\n  This routine will perform \\a lossy compression on the three-dimensional\n  coordinate data data specified and store it in the XDR file. Double will\n  NOT give you any extra precision since the coordinates are compressed. This\n  routine just avoids allocating a temporary array of floats.\n\n  The lossy part of the compression consists of multiplying each\n  coordinate with the precision argument and then rounding to integers.\n  We suggest a default value of 1000.0, which means you are guaranteed\n  three decimals of accuracy. The only limitation is that scaled coordinates\n  must still fit in an integer variable, so if the precision is 1000.0 the\n  coordinate magnitudes must be less than +-2e6.\n\n  \\param ptr        Pointer to coordinates to compress (length 3*ncoord)\n  \\param ncoord     Number of coordinate triplets in data\n  \\param precision  Scaling factor for lossy compression. If it is <=0, the\n                    default value of 1000.0 is used.\n  \\param xfp        Handle to portably binary file\n\n  \\return           Number of coordinate triplets written.\n                    IMPORTANT: Check that this is equal to ncoord - if it is\n                    negative, an error occured. This should not happen with\n                    normal data, but if your coordinates are NaN or very\n                    large (>1e6) it is not possible to use the compression.\n\n  \\warning          The compression algorithm is not part of the XDR standard,\n                    and very complicated, so you will need this xdrfile module\n                    to read it later."]
    pub fn xdrfile_compress_coord_double(
        ptr: *mut f64,
        ncoord: ::std::os::raw::c_int,
        precision: f64,
        xfp: *mut XDRFILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Decompress coordiates from XDR file to array of doubles\n\n  This routine will decompress three-dimensional coordinate data previously\n  stored in an XDR file and store it in the specified array of doubles.\n  Double will NOT give you any extra precision since the coordinates are\n  compressed. This routine just avoids allocating a temporary array of floats.\n\n  The precision used during the earlier compression is read from the file\n  and returned - you cannot adjust the accuracy at this stage.\n\n  \\param ptr        Pointer to coordinates to compress (length>= 3*ncoord)\n  \\param ncoord     Max number of coordinate triplets to read on input, actual\n                    number of coordinate triplets read on return. If this\n                    is smaller than the number of coordinates in the frame an\n                    error will occur.\n  \\param precision  The precision used in the previous compression will be\n                    written to this variable on return.\n  \\param xfp        Handle to portably binary file\n\n  \\return           Number of coordinate triplets read. If this is negative,\n                    an error occured.\n\n  \\warning          Since we cannot count on being able to set/get the\n                    position of large files (>2Gb), it is not possible to\n                    recover from errors by re-reading the frame if the\n                    storage area you provided was too small. To avoid this\n                    from happening, we recommend that you store the number of\n                    coordinates triplet as an integer either in a header or\n                    just before the compressed coordinate data, so you can\n                    read it first and allocated enough memory."]
    pub fn xdrfile_decompress_coord_double(
        ptr: *mut f64,
        ncoord: *mut ::std::os::raw::c_int,
        precision: *mut f64,
        xfp: *mut XDRFILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn read_trr_natoms(
        fn_: *mut ::std::os::raw::c_char,
        natoms: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn read_trr_nframes(
        fn_: *mut ::std::os::raw::c_char,
        nframes: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn read_trr(
        xd: *mut XDRFILE,
        natoms: ::std::os::raw::c_int,
        step: *mut ::std::os::raw::c_int,
        t: *mut f32,
        lambda: *mut f32,
        box_: *mut [f32; 3usize],
        x: *mut rvec,
        v: *mut rvec,
        f: *mut rvec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn write_trr(
        xd: *mut XDRFILE,
        natoms: ::std::os::raw::c_int,
        step: ::std::os::raw::c_int,
        t: f32,
        lambda: f32,
        box_: *mut [f32; 3usize],
        x: *mut rvec,
        v: *mut rvec,
        f: *mut rvec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn read_xtc_natoms(
        fn_: *mut ::std::os::raw::c_char,
        natoms: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn read_xtc_nframes(
        fn_: *mut ::std::os::raw::c_char,
        nframes: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn read_xtc(
        xd: *mut XDRFILE,
        natoms: ::std::os::raw::c_int,
        step: *mut ::std::os::raw::c_int,
        time: *mut f32,
        box_: *mut [f32; 3usize],
        x: *mut rvec,
        prec: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn write_xtc(
        xd: *mut XDRFILE,
        natoms: ::std::os::raw::c_int,
        step: ::std::os::raw::c_int,
        time: f32,
        box_: *const [f32; 3usize],
        x: *const rvec,
        prec: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xdr_xtc_get_natoms(
        handle: *mut XDRFILE,
        natoms: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xtc_get_current_frame_number(
        handle: *mut XDRFILE,
        natoms: ::std::os::raw::c_int,
        bOK: *mut bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xtc_get_next_frame_number(
        handle: *mut XDRFILE,
        natoms: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xtc_get_current_frame_time(
        handle: *mut XDRFILE,
        natoms: ::std::os::raw::c_int,
        bOK: *mut bool,
    ) -> f32;
}
extern "C" {
    pub fn xtc_get_next_frame_time(
        handle: *mut XDRFILE,
        natoms: ::std::os::raw::c_int,
        bOK: *mut bool,
    ) -> f32;
}
extern "C" {
    pub fn xdr_xtc_estimate_dt(
        handle: *mut XDRFILE,
        natoms: ::std::os::raw::c_int,
        bOK: *mut bool,
    ) -> f32;
}
extern "C" {
    pub fn xdr_xtc_get_last_frame_number(
        handle: *mut XDRFILE,
        natoms: ::std::os::raw::c_int,
        bOK: *mut bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xdr_xtc_get_last_frame_time(
        handle: *mut XDRFILE,
        natoms: ::std::os::raw::c_int,
        bOK: *mut bool,
    ) -> f32;
}
extern "C" {
    pub fn xdr_xtc_seek_frame(
        frame: ::std::os::raw::c_int,
        handle: *mut XDRFILE,
        natoms: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xdr_xtc_seek_time(
        time: f32,
        handle: *mut XDRFILE,
        natoms: ::std::os::raw::c_int,
        bSeekForwardOnly: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn check_trr_content(
        handle: *mut XDRFILE,
        natoms: *mut ::std::os::raw::c_int,
        xsz: *mut ::std::os::raw::c_int,
        vsz: *mut ::std::os::raw::c_int,
        fsz: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
