from __future__ import annotations

import builtins
import datetime
import typing


class Atom:
    name: builtins.str
    resname: builtins.str
    resid: builtins.int
    atomic_number: builtins.int
    mass: builtins.float
    charge: builtins.float
    type_name: builtins.str
    type_id: builtins.int
    chain: builtins.str
    bfactor: builtins.float
    occupancy: builtins.float

    def __new__(cls) -> Atom: ...


class Particle:
    id: builtins.int
    pos: typing.Any
    x: builtins.float
    y: builtins.float
    z: builtins.float
    atom: typing.Any
    name: builtins.str
    resname: builtins.str
    resid: builtins.int
    resindex: builtins.int
    atomic_number: builtins.int
    mass: builtins.float
    charge: builtins.float
    type_name: builtins.str
    type_id: builtins.int
    chain: builtins.str
    bfactor: builtins.float
    occupancy: builtins.float


class Topology:
    def __len__(self) -> builtins.int: ...


class State:
    box: PeriodicBox
    time: builtins.float

    def __len__(self) -> builtins.int: ...
    def set_box_from(self, arg: System | Sel) -> None: ...


class PeriodicBox:
    @typing.overload
    def __new__(cls, matrix: typing.Any) -> PeriodicBox: ...
    @typing.overload
    def __new__(cls, vectors: typing.Any, angles: typing.Any) -> PeriodicBox: ...

    def to_vectors_angles(self) -> tuple[typing.Any, typing.Any]: ...
    def shortest_vector(self, arr: typing.Any, dims: list[builtins.bool] = [True, True, True]) -> typing.Any: ...
    def closest_image(self, point: typing.Any, target: typing.Any, dims: list[builtins.bool] = [True, True, True]) -> typing.Any: ...
    def get_matrix(self) -> typing.Any: ...
    def to_box_coords(self, point: typing.Any) -> typing.Any: ...
    def to_lab_coords(self, point: typing.Any) -> typing.Any: ...
    def get_box_extents(self) -> typing.Any: ...
    def get_lab_extents(self) -> typing.Any: ...
    def is_triclinic(self) -> builtins.bool: ...
    def distance_squared(self, p1: typing.Any, p2: typing.Any, dims: list[builtins.bool]) -> builtins.float: ...
    def distance(self, p1: typing.Any, p2: typing.Any, dims: list[builtins.bool]) -> builtins.float: ...
    def wrap_point(self, p: typing.Any) -> typing.Any: ...


class FileStats:
    elapsed_time: datetime.timedelta
    frames_processed: builtins.int
    cur_t: builtins.float

    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...


class FileHandler:
    stats: FileStats
    file_name: builtins.str

    def __new__(cls, fname: builtins.str, mode: builtins.str) -> FileHandler: ...
    def read(self) -> tuple[Topology, State]: ...
    def read_topology(self) -> Topology: ...
    def read_state(self) -> State: ...
    def write(self, data: typing.Any) -> None: ...
    def write_topology(self, data: typing.Any) -> None: ...
    def write_state(self, data: typing.Any) -> None: ...
    def __iter__(self) -> FileHandler: ...
    def __next__(self) -> typing.Optional[State]: ...
    def skip_to_frame(self, fr: builtins.int) -> None: ...
    def skip_to_time(self, t: builtins.float) -> None: ...


class System:
    state: State
    topology: Topology
    time: builtins.float
    box: PeriodicBox

    @typing.overload
    def __new__(cls) -> System: ...
    @typing.overload
    def __new__(cls, fname: builtins.str) -> System: ...
    @typing.overload
    def __new__(cls, topology: Topology, state: State) -> System: ...

    def __len__(self) -> builtins.int: ...
    def __call__(self, arg: builtins.str | tuple[builtins.int, builtins.int] | list[builtins.int] | None = None) -> Sel: ...
    def replace_state_deep(self, st: State) -> None: ...
    def save(self, fname: builtins.str) -> None: ...
    def remove(self, arg: Sel | builtins.str | tuple[builtins.int, builtins.int] | list[builtins.int]) -> None: ...
    @typing.overload
    def append(self, arg: Sel | builtins.str | tuple[builtins.int, builtins.int] | list[builtins.int]) -> None: ...
    @typing.overload
    def append(self, atom: Atom, pos: typing.Any) -> None: ...
    def set_box_from(self, src: System | Sel) -> None: ...
    def iter_pos(self) -> SysPosIterator: ...
    def iter_atoms(self) -> SysAtomIterator: ...


class Sel:
    index: typing.Any
    coords: typing.Any
    system: System
    state: State
    topology: Topology
    time: builtins.float
    box: PeriodicBox

    def __len__(self) -> builtins.int: ...
    def __call__(self, arg: builtins.str | tuple[builtins.int, builtins.int] | list[builtins.int]) -> Sel: ...
    def __getitem__(self, i: builtins.int) -> Particle: ...
    def __iter__(self) -> typing.Iterator[Particle]: ...
    def replace_state_deep(self, st: State) -> None: ...
    def set_same_chain(self, val: builtins.str) -> None: ...
    def set_same_resname(self, val: builtins.str) -> None: ...
    def set_same_resid(self, val: builtins.int) -> None: ...
    def set_same_name(self, val: builtins.str) -> None: ...
    def set_same_mass(self, val: builtins.float) -> None: ...
    def set_same_bfactor(self, val: builtins.float) -> None: ...
    def set_box_from(self, sys: System) -> None: ...
    def com(self, dims: list[builtins.bool] = [False, False, False]) -> typing.Any: ...
    def cog(self, dims: list[builtins.bool] = [False, False, False]) -> typing.Any: ...
    def principal_transform(self) -> typing.Any: ...
    def principal_transform_pbc(self) -> typing.Any: ...
    def apply_transform(self, tr: typing.Any) -> None: ...
    def gyration(self) -> builtins.float: ...
    def gyration_pbc(self) -> builtins.float: ...
    def min_max(self) -> tuple[typing.Any, typing.Any]: ...
    def inertia(self) -> tuple[typing.Any, typing.Any]: ...
    def inertia_pbc(self) -> tuple[typing.Any, typing.Any]: ...
    def save(self, fname: builtins.str) -> None: ...
    def translate(self, arg: typing.Any) -> None: ...
    def split_resindex(self) -> list[Sel]: ...
    def split_chain(self) -> list[Sel]: ...
    def split_molecule(self) -> list[Sel]: ...
    def to_gromacs_ndx(self, name: builtins.str) -> builtins.str: ...
    def iter_pos(self) -> SelPosIterator: ...
    def iter_atoms(self) -> SelAtomIterator: ...


class SasaResults:
    areas: typing.Any
    volumes: typing.Any
    total_area: builtins.float
    total_volume: builtins.float


class NdxFile:
    def __new__(cls, fname: builtins.str) -> NdxFile: ...
    def get_group_as_sel(self, gr_name: builtins.str, sys: System) -> Sel: ...


class SysPosIterator:
    def __iter__(self) -> SysPosIterator: ...
    def __next__(self) -> typing.Any: ...


class SysAtomIterator:
    def __iter__(self) -> SysAtomIterator: ...
    def __next__(self) -> typing.Any: ...


class SelPosIterator:
    def __iter__(self) -> SelPosIterator: ...
    def __next__(self) -> typing.Any: ...


class SelAtomIterator:
    def __iter__(self) -> SelAtomIterator: ...
    def __next__(self) -> typing.Any: ...


def greeting() -> None: ...
def fit_transform(sel1: Sel, sel2: Sel) -> typing.Any: ...
def fit_transform_matching(sel1: Sel, sel2: Sel) -> typing.Any: ...
def rmsd_py(sel1: Sel, sel2: Sel) -> builtins.float: ...
def rmsd_mw(sel1: Sel, sel2: Sel) -> builtins.float: ...
def distance_search(
    cutoff: builtins.float | builtins.str,
    data1: Sel,
    data2: Sel | None = None,
    dims: list[builtins.bool] = [False, False, False],
) -> tuple[typing.Any, typing.Any]: ...
