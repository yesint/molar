/* automatically generated by rust-bindgen 0.71.1 */

pub const F_OK: u32 = 0;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub type real = f32;
#[repr(C)]
#[repr(align(8))]
pub struct t_inputrec {
    pub _bindgen_opaque_blob: [u64; 110usize],
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN10t_inputrecC1Ev"]
    pub fn t_inputrec_t_inputrec(this: *mut t_inputrec);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN10t_inputrecD1Ev"]
    pub fn t_inputrec_t_inputrec_destructor(this: *mut t_inputrec);
}
impl t_inputrec {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        t_inputrec_t_inputrec(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        t_inputrec_t_inputrec_destructor(self)
    }
}
pub const StateEntry_Lambda: StateEntry = 0;
pub const StateEntry_Box: StateEntry = 1;
pub const StateEntry_BoxRel: StateEntry = 2;
pub const StateEntry_BoxV: StateEntry = 3;
pub const StateEntry_PressurePrevious: StateEntry = 4;
pub const StateEntry_Nhxi: StateEntry = 5;
pub const StateEntry_ThermInt: StateEntry = 6;
pub const StateEntry_X: StateEntry = 7;
pub const StateEntry_V: StateEntry = 8;
pub const StateEntry_SDxNotSupported: StateEntry = 9;
pub const StateEntry_Cgp: StateEntry = 10;
pub const StateEntry_LDRngNotSupported: StateEntry = 11;
pub const StateEntry_LDRngINotSupported: StateEntry = 12;
pub const StateEntry_DisreInitF: StateEntry = 13;
pub const StateEntry_DisreRm3Tav: StateEntry = 14;
pub const StateEntry_OrireInitF: StateEntry = 15;
pub const StateEntry_OrireDtav: StateEntry = 16;
pub const StateEntry_SVirPrev: StateEntry = 17;
pub const StateEntry_Nhvxi: StateEntry = 18;
pub const StateEntry_Veta: StateEntry = 19;
pub const StateEntry_Vol0: StateEntry = 20;
pub const StateEntry_Nhpresxi: StateEntry = 21;
pub const StateEntry_Nhpresvxi: StateEntry = 22;
pub const StateEntry_FVirPrev: StateEntry = 23;
pub const StateEntry_FepState: StateEntry = 24;
pub const StateEntry_MCRngNotSupported: StateEntry = 25;
pub const StateEntry_MCRngINotSupported: StateEntry = 26;
pub const StateEntry_BarosInt: StateEntry = 27;
pub const StateEntry_PullComPrevStep: StateEntry = 28;
pub const StateEntry_Count: StateEntry = 29;
#[doc = " \\brief Enum for all entries in \\p t_state\n\n These enums are used in flags as (1<<est...).\n The order of these enums should not be changed,\n since that affects the checkpoint (.cpt) file format."]
pub type StateEntry = ::std::os::raw::c_int;
#[doc = " \\brief The microstate of the system\n\n The global state will contain complete data for all used entries.\n The local state with domain decomposition will have partial entries\n for which \\p stateEntryIsAtomProperty() is true. Some entries that\n are used in the global state might not be present in the local state.\n \\todo Move pure observables history to ObservablesHistory."]
#[repr(C)]
#[repr(align(8))]
pub struct t_state {
    pub _bindgen_opaque_blob: [u64; 104usize],
}
unsafe extern "C" {
    #[doc = "! Change the number of atoms represented by this state, allocating memory as needed."]
    #[link_name = "\u{1}_ZN7t_state14changeNumAtomsEi"]
    pub fn t_state_changeNumAtoms(this: *mut t_state, numAtoms: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = "! Set entry \\p entry to present, resizes corresponding vector to numAtoms() when relevant"]
    #[link_name = "\u{1}_ZN7t_state8addEntryE10StateEntry"]
    pub fn t_state_addEntry(this: *mut t_state, entry: StateEntry);
}
unsafe extern "C" {
    #[doc = "! Sets the present entries to the ones set in \\p flags"]
    #[link_name = "\u{1}_ZN7t_state8setFlagsEi"]
    pub fn t_state_setFlags(this: *mut t_state, flags: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN7t_stateC1Ev"]
    pub fn t_state_t_state(this: *mut t_state);
}
impl t_state {
    #[inline]
    pub unsafe fn changeNumAtoms(&mut self, numAtoms: ::std::os::raw::c_int) {
        t_state_changeNumAtoms(self, numAtoms)
    }
    #[inline]
    pub unsafe fn addEntry(&mut self, entry: StateEntry) {
        t_state_addEntry(self, entry)
    }
    #[inline]
    pub unsafe fn setFlags(&mut self, flags: ::std::os::raw::c_int) {
        t_state_setFlags(self, flags)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        t_state_t_state(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[doc = " \\libinternal \\brief\n Legacy symbol table entry as linked list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_symbuf {
    #[doc = "! Number of entries in this item"]
    pub bufsize: ::std::os::raw::c_int,
    #[doc = "! Storage for strings in this item."]
    pub buf: *mut *mut ::std::os::raw::c_char,
    #[doc = "! Next item in linked list."]
    pub next: *mut t_symbuf,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_symtab {
    #[doc = "! Total number of entries stored."]
    pub nr: ::std::os::raw::c_int,
    #[doc = "! First item in linked list of storage elements."]
    pub symbuf: *mut t_symbuf,
}
pub const ParticleType_Atom: ParticleType = 0;
pub const ParticleType_Nucleus: ParticleType = 1;
pub const ParticleType_Shell: ParticleType = 2;
pub const ParticleType_Bond: ParticleType = 3;
pub const ParticleType_VSite: ParticleType = 4;
pub const ParticleType_Count: ParticleType = 5;
pub type ParticleType = ::std::os::raw::c_int;
pub const PdbRecordType_Atom: PdbRecordType = 0;
pub const PdbRecordType_Hetatm: PdbRecordType = 1;
pub const PdbRecordType_Anisou: PdbRecordType = 2;
pub const PdbRecordType_Cryst1: PdbRecordType = 3;
pub const PdbRecordType_Compound: PdbRecordType = 4;
pub const PdbRecordType_Model: PdbRecordType = 5;
pub const PdbRecordType_EndModel: PdbRecordType = 6;
pub const PdbRecordType_Ter: PdbRecordType = 7;
pub const PdbRecordType_Header: PdbRecordType = 8;
pub const PdbRecordType_Title: PdbRecordType = 9;
pub const PdbRecordType_Remark: PdbRecordType = 10;
pub const PdbRecordType_Conect: PdbRecordType = 11;
pub const PdbRecordType_Count: PdbRecordType = 12;
pub type PdbRecordType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_atom {
    pub m: real,
    pub q: real,
    pub mB: real,
    pub qB: real,
    pub type_: ::std::os::raw::c_ushort,
    pub typeB: ::std::os::raw::c_ushort,
    pub ptype: ParticleType,
    pub resind: ::std::os::raw::c_int,
    pub atomnumber: ::std::os::raw::c_int,
    pub elem: [::std::os::raw::c_char; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_resinfo {
    pub name: *mut *mut ::std::os::raw::c_char,
    pub nr: ::std::os::raw::c_int,
    pub ic: ::std::os::raw::c_uchar,
    pub chainnum: ::std::os::raw::c_int,
    pub chainid: ::std::os::raw::c_char,
    pub rtp: *mut *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_pdbinfo {
    pub type_: PdbRecordType,
    pub atomnr: ::std::os::raw::c_int,
    pub altloc: ::std::os::raw::c_char,
    pub atomnm: [::std::os::raw::c_char; 6usize],
    pub occup: real,
    pub bfac: real,
    pub bAnisotropic: bool,
    pub uij: [::std::os::raw::c_int; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_atoms {
    pub nr: ::std::os::raw::c_int,
    pub atom: *mut t_atom,
    pub atomname: *mut *mut *mut ::std::os::raw::c_char,
    pub atomtype: *mut *mut *mut ::std::os::raw::c_char,
    pub atomtypeB: *mut *mut *mut ::std::os::raw::c_char,
    pub nres: ::std::os::raw::c_int,
    pub resinfo: *mut t_resinfo,
    pub pdbinfo: *mut t_pdbinfo,
    pub haveMass: bool,
    pub haveCharge: bool,
    pub haveType: bool,
    pub haveBState: bool,
    pub havePdbInfo: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_block {
    pub nr: ::std::os::raw::c_int,
    pub index: *mut ::std::os::raw::c_int,
    pub nalloc_index: ::std::os::raw::c_int,
}
pub type t_iatom = ::std::os::raw::c_int;
pub const F_BONDS: _bindgen_ty_61 = 0;
pub const F_G96BONDS: _bindgen_ty_61 = 1;
pub const F_MORSE: _bindgen_ty_61 = 2;
pub const F_CUBICBONDS: _bindgen_ty_61 = 3;
pub const F_CONNBONDS: _bindgen_ty_61 = 4;
pub const F_HARMONIC: _bindgen_ty_61 = 5;
pub const F_FENEBONDS: _bindgen_ty_61 = 6;
pub const F_TABBONDS: _bindgen_ty_61 = 7;
pub const F_TABBONDSNC: _bindgen_ty_61 = 8;
pub const F_RESTRBONDS: _bindgen_ty_61 = 9;
pub const F_ANGLES: _bindgen_ty_61 = 10;
pub const F_G96ANGLES: _bindgen_ty_61 = 11;
pub const F_RESTRANGLES: _bindgen_ty_61 = 12;
pub const F_LINEAR_ANGLES: _bindgen_ty_61 = 13;
pub const F_CROSS_BOND_BONDS: _bindgen_ty_61 = 14;
pub const F_CROSS_BOND_ANGLES: _bindgen_ty_61 = 15;
pub const F_UREY_BRADLEY: _bindgen_ty_61 = 16;
pub const F_QUARTIC_ANGLES: _bindgen_ty_61 = 17;
pub const F_TABANGLES: _bindgen_ty_61 = 18;
pub const F_PDIHS: _bindgen_ty_61 = 19;
pub const F_RBDIHS: _bindgen_ty_61 = 20;
pub const F_RESTRDIHS: _bindgen_ty_61 = 21;
pub const F_CBTDIHS: _bindgen_ty_61 = 22;
pub const F_FOURDIHS: _bindgen_ty_61 = 23;
pub const F_IDIHS: _bindgen_ty_61 = 24;
pub const F_PIDIHS: _bindgen_ty_61 = 25;
pub const F_TABDIHS: _bindgen_ty_61 = 26;
pub const F_CMAP: _bindgen_ty_61 = 27;
pub const F_GB12_NOLONGERUSED: _bindgen_ty_61 = 28;
pub const F_GB13_NOLONGERUSED: _bindgen_ty_61 = 29;
pub const F_GB14_NOLONGERUSED: _bindgen_ty_61 = 30;
pub const F_GBPOL_NOLONGERUSED: _bindgen_ty_61 = 31;
pub const F_NPSOLVATION_NOLONGERUSED: _bindgen_ty_61 = 32;
pub const F_LJ14: _bindgen_ty_61 = 33;
pub const F_COUL14: _bindgen_ty_61 = 34;
pub const F_LJC14_Q: _bindgen_ty_61 = 35;
pub const F_LJC_PAIRS_NB: _bindgen_ty_61 = 36;
pub const F_LJ: _bindgen_ty_61 = 37;
pub const F_BHAM: _bindgen_ty_61 = 38;
pub const F_LJ_LR_NOLONGERUSED: _bindgen_ty_61 = 39;
pub const F_BHAM_LR_NOLONGERUSED: _bindgen_ty_61 = 40;
pub const F_DISPCORR: _bindgen_ty_61 = 41;
pub const F_COUL_SR: _bindgen_ty_61 = 42;
pub const F_COUL_LR_NOLONGERUSED: _bindgen_ty_61 = 43;
pub const F_RF_EXCL: _bindgen_ty_61 = 44;
pub const F_COUL_RECIP: _bindgen_ty_61 = 45;
pub const F_LJ_RECIP: _bindgen_ty_61 = 46;
pub const F_DPD: _bindgen_ty_61 = 47;
pub const F_POLARIZATION: _bindgen_ty_61 = 48;
pub const F_WATER_POL: _bindgen_ty_61 = 49;
pub const F_THOLE_POL: _bindgen_ty_61 = 50;
pub const F_ANHARM_POL: _bindgen_ty_61 = 51;
pub const F_POSRES: _bindgen_ty_61 = 52;
pub const F_FBPOSRES: _bindgen_ty_61 = 53;
pub const F_DISRES: _bindgen_ty_61 = 54;
pub const F_DISRESVIOL: _bindgen_ty_61 = 55;
pub const F_ORIRES: _bindgen_ty_61 = 56;
pub const F_ORIRESDEV: _bindgen_ty_61 = 57;
pub const F_ANGRES: _bindgen_ty_61 = 58;
pub const F_ANGRESZ: _bindgen_ty_61 = 59;
pub const F_DIHRES: _bindgen_ty_61 = 60;
pub const F_DIHRESVIOL: _bindgen_ty_61 = 61;
pub const F_CONSTR: _bindgen_ty_61 = 62;
pub const F_CONSTRNC: _bindgen_ty_61 = 63;
pub const F_SETTLE: _bindgen_ty_61 = 64;
pub const F_VSITE1: _bindgen_ty_61 = 65;
pub const F_VSITE2: _bindgen_ty_61 = 66;
pub const F_VSITE2FD: _bindgen_ty_61 = 67;
pub const F_VSITE3: _bindgen_ty_61 = 68;
pub const F_VSITE3FD: _bindgen_ty_61 = 69;
pub const F_VSITE3FAD: _bindgen_ty_61 = 70;
pub const F_VSITE3OUT: _bindgen_ty_61 = 71;
pub const F_VSITE4FD: _bindgen_ty_61 = 72;
pub const F_VSITE4FDN: _bindgen_ty_61 = 73;
pub const F_VSITEN: _bindgen_ty_61 = 74;
pub const F_COM_PULL: _bindgen_ty_61 = 75;
pub const F_DENSITYFITTING: _bindgen_ty_61 = 76;
pub const F_EQM: _bindgen_ty_61 = 77;
pub const F_ENNPOT: _bindgen_ty_61 = 78;
pub const F_EPOT: _bindgen_ty_61 = 79;
pub const F_EKIN: _bindgen_ty_61 = 80;
pub const F_ETOT: _bindgen_ty_61 = 81;
pub const F_ECONSERVED: _bindgen_ty_61 = 82;
pub const F_TEMP: _bindgen_ty_61 = 83;
pub const F_VTEMP_NOLONGERUSED: _bindgen_ty_61 = 84;
pub const F_PDISPCORR: _bindgen_ty_61 = 85;
pub const F_PRES: _bindgen_ty_61 = 86;
pub const F_DVDL_CONSTR: _bindgen_ty_61 = 87;
pub const F_DVDL: _bindgen_ty_61 = 88;
pub const F_DKDL: _bindgen_ty_61 = 89;
pub const F_DVDL_COUL: _bindgen_ty_61 = 90;
pub const F_DVDL_VDW: _bindgen_ty_61 = 91;
pub const F_DVDL_BONDED: _bindgen_ty_61 = 92;
pub const F_DVDL_RESTRAINT: _bindgen_ty_61 = 93;
#[doc = "!< Not calculated for now, but should just be the energy (NVT) or enthalpy (NPT), or 0 (NVE)."]
pub const F_DVDL_TEMPERATURE: _bindgen_ty_61 = 94;
#[doc = "!< This number is for the total number of energies."]
pub const F_NRE: _bindgen_ty_61 = 95;
#[doc = " \\brief Interaction function enums.\n\n This MUST correspond to the t_interaction_function[F_NRE] in src/gromacs/topology/ifunc.cpp."]
pub type _bindgen_ty_61 = ::std::os::raw::c_uint;
#[doc = " \\brief\n Union of various interaction paramters.\n\n Some parameters have A and B values for free energy calculations.\n The B values are not used for regular simulations of course.\n Free Energy for nonbondeds can be computed by changing the atom type.\n The harmonic type is used for all harmonic potentials:\n bonds, angles and improper dihedrals.\n\n No free energy supported for cubic bonds, FENE, WPOL or cross terms."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union t_iparams {
    pub bham: t_iparams__bindgen_ty_1,
    pub harmonic: t_iparams__bindgen_ty_2,
    pub linangle: t_iparams__bindgen_ty_3,
    pub restraint: t_iparams__bindgen_ty_4,
    pub cubic: t_iparams__bindgen_ty_5,
    pub fene: t_iparams__bindgen_ty_6,
    pub cross_bb: t_iparams__bindgen_ty_7,
    pub cross_ba: t_iparams__bindgen_ty_8,
    pub u_b: t_iparams__bindgen_ty_9,
    pub qangle: t_iparams__bindgen_ty_10,
    pub polarize: t_iparams__bindgen_ty_11,
    pub anharm_polarize: t_iparams__bindgen_ty_12,
    pub wpol: t_iparams__bindgen_ty_13,
    pub thole: t_iparams__bindgen_ty_14,
    pub lj: t_iparams__bindgen_ty_15,
    pub lj14: t_iparams__bindgen_ty_16,
    pub ljc14: t_iparams__bindgen_ty_17,
    pub ljcnb: t_iparams__bindgen_ty_18,
    pub pdihs: t_iparams__bindgen_ty_19,
    pub constr: t_iparams__bindgen_ty_20,
    pub settle: t_iparams__bindgen_ty_21,
    pub morse: t_iparams__bindgen_ty_22,
    pub posres: t_iparams__bindgen_ty_23,
    pub fbposres: t_iparams__bindgen_ty_24,
    pub rbdihs: t_iparams__bindgen_ty_25,
    pub cbtdihs: t_iparams__bindgen_ty_26,
    pub vsite: t_iparams__bindgen_ty_27,
    pub vsiten: t_iparams__bindgen_ty_28,
    pub disres: t_iparams__bindgen_ty_29,
    pub dihres: t_iparams__bindgen_ty_30,
    pub orires: t_iparams__bindgen_ty_31,
    pub tab: t_iparams__bindgen_ty_32,
    pub cmap: t_iparams__bindgen_ty_33,
    pub generic: t_iparams__bindgen_ty_34,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_1 {
    pub a: real,
    pub b: real,
    pub c: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_2 {
    pub rA: real,
    pub krA: real,
    pub rB: real,
    pub krB: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_3 {
    pub klinA: real,
    pub aA: real,
    pub klinB: real,
    pub aB: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_4 {
    pub lowA: real,
    pub up1A: real,
    pub up2A: real,
    pub kA: real,
    pub lowB: real,
    pub up1B: real,
    pub up2B: real,
    pub kB: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_5 {
    pub b0: real,
    pub kb: real,
    pub kcub: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_6 {
    pub bm: real,
    pub kb: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_7 {
    pub r1e: real,
    pub r2e: real,
    pub krr: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_8 {
    pub r1e: real,
    pub r2e: real,
    pub r3e: real,
    pub krt: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_9 {
    pub thetaA: real,
    pub kthetaA: real,
    pub r13A: real,
    pub kUBA: real,
    pub thetaB: real,
    pub kthetaB: real,
    pub r13B: real,
    pub kUBB: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_10 {
    pub theta: real,
    pub c: [real; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_11 {
    pub alpha: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_12 {
    pub alpha: real,
    pub drcut: real,
    pub khyp: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_13 {
    pub al_x: real,
    pub al_y: real,
    pub al_z: real,
    pub rOH: real,
    pub rHH: real,
    pub rOD: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_14 {
    pub a: real,
    pub alpha1: real,
    pub alpha2: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_15 {
    pub c6: real,
    pub c12: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_16 {
    pub c6A: real,
    pub c12A: real,
    pub c6B: real,
    pub c12B: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_17 {
    pub fqq: real,
    pub qi: real,
    pub qj: real,
    pub c6: real,
    pub c12: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_18 {
    pub qi: real,
    pub qj: real,
    pub c6: real,
    pub c12: real,
}
#[doc = " \\brief Proper dihedrals.\n\n Proper dihedrals can not have different multiplicity when\n doing free energy calculations, because the potential would not\n be periodic anymore."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_19 {
    pub phiA: real,
    pub cpA: real,
    pub mult: ::std::os::raw::c_int,
    pub phiB: real,
    pub cpB: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_20 {
    pub dA: real,
    pub dB: real,
}
#[doc = " \\brief SETTLE.\n\n SETTLE can not be used for Free energy calculations of water bond geometry.\n Use shake (or lincs) instead if you have to change the water bonds."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_21 {
    pub doh: real,
    pub dhh: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_22 {
    pub b0A: real,
    pub cbA: real,
    pub betaA: real,
    pub b0B: real,
    pub cbB: real,
    pub betaB: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_23 {
    pub pos0A: [real; 3usize],
    pub fcA: [real; 3usize],
    pub pos0B: [real; 3usize],
    pub fcB: [real; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_24 {
    pub pos0: [real; 3usize],
    pub r: real,
    pub k: real,
    pub geom: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_25 {
    pub rbcA: [real; 6usize],
    pub rbcB: [real; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_26 {
    pub cbtcA: [real; 6usize],
    pub cbtcB: [real; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_27 {
    pub a: real,
    pub b: real,
    pub c: real,
    pub d: real,
    pub e: real,
    pub f: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_28 {
    pub n: ::std::os::raw::c_int,
    pub a: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_29 {
    pub low: real,
    pub up1: real,
    pub up2: real,
    pub kfac: real,
    pub type_: ::std::os::raw::c_int,
    pub label: ::std::os::raw::c_int,
    pub npair: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_30 {
    pub phiA: real,
    pub dphiA: real,
    pub kfacA: real,
    pub phiB: real,
    pub dphiB: real,
    pub kfacB: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_31 {
    pub ex: ::std::os::raw::c_int,
    pub power: ::std::os::raw::c_int,
    pub label: ::std::os::raw::c_int,
    pub c: real,
    pub obs: real,
    pub kfac: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_32 {
    pub table: ::std::os::raw::c_int,
    pub kA: real,
    pub kB: real,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_33 {
    pub cmapA: ::std::os::raw::c_int,
    pub cmapB: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_iparams__bindgen_ty_34 {
    pub buf: [real; 12usize],
}
pub type t_functype = ::std::os::raw::c_int;
#[doc = " \\brief Deprecated list of listed interactions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_ilist {
    #[doc = "! The size (nr elements) of the interactions array (iatoms[])."]
    pub nr: ::std::os::raw::c_int,
    pub iatoms: *mut t_iatom,
    pub nalloc: ::std::os::raw::c_int,
}
#[doc = " \\brief Deprecated interation definitions, used in t_topology\n\n The struct t_idef defines all the interactions for the complete\n simulation. The structure is setup in such a way that the multinode\n version of the program  can use it as easy as the single node version."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_idef {
    #[doc = "! Defines the number of elements in functype[] and param[]."]
    pub ntypes: ::std::os::raw::c_int,
    #[doc = "! The number of atomtypes."]
    pub atnr: ::std::os::raw::c_int,
    #[doc = " Array of length ntypes, defines for every force type what type of\n function to use. Every \"bond\" with the same function but different\n force parameters is a different force type. The type identifier in the\n forceatoms[] array is an index in this array."]
    pub functype: *mut t_functype,
    #[doc = " Array of length ntypes, defines the parameters for every interaction\n type. The type identifier in the actual interaction list\n (ilist[ftype].iatoms[]) is an index in this array."]
    pub iparams: *mut t_iparams,
    pub fudgeQQ: real,
    #[doc = " Defines the parameters for position restraints only.\n Position restraints are the only interactions that have different\n parameters (reference positions) for different molecules\n of the same type. ilist[F_POSRES].iatoms[] is an index in this array."]
    pub iparams_posres: *mut t_iparams,
    #[doc = " Defines the parameters for position restraints only.\n Position restraints are the only interactions that have different\n parameters (reference positions) for different molecules\n of the same type. ilist[F_POSRES].iatoms[] is an index in this array."]
    pub iparams_fbposres: *mut t_iparams,
    #[doc = " The list of interactions for each type. Note that some,\n such as LJ and COUL will have 0 entries."]
    pub il: [t_ilist; 95usize],
    #[doc = "! The state of the sorting of il, values are provided above."]
    pub ilsort: ::std::os::raw::c_int,
}
#[repr(C)]
#[repr(align(8))]
pub struct gmx_mtop_t {
    pub _bindgen_opaque_blob: [u64; 96usize],
}
unsafe extern "C" {
    #[doc = " \\brief Finalize this data structure.\n\n Should be called after generating or reading mtop, to set some compute\n intesive variables to avoid N^2 operations later on.\n\n \\todo Move into a builder class, once available."]
    #[link_name = "\u{1}_ZN10gmx_mtop_t8finalizeEv"]
    pub fn gmx_mtop_t_finalize(this: *mut gmx_mtop_t);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN10gmx_mtop_tC1Ev"]
    pub fn gmx_mtop_t_gmx_mtop_t(this: *mut gmx_mtop_t);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN10gmx_mtop_tD1Ev"]
    pub fn gmx_mtop_t_gmx_mtop_t_destructor(this: *mut gmx_mtop_t);
}
impl gmx_mtop_t {
    #[inline]
    pub unsafe fn finalize(&mut self) {
        gmx_mtop_t_finalize(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        gmx_mtop_t_gmx_mtop_t(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        gmx_mtop_t_gmx_mtop_t_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_topology {
    pub name: *mut *mut ::std::os::raw::c_char,
    pub idef: t_idef,
    pub atoms: t_atoms,
    pub mols: t_block,
    pub bIntermolecularInteractions: bool,
    pub symtab: t_symtab,
}
#[repr(C)]
pub struct TprHelper {
    pub mtop: gmx_mtop_t,
    pub top: t_topology,
    pub state: t_state,
    pub ir: t_inputrec,
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN9TprHelper7get_topEv"]
    pub fn TprHelper_get_top(this: *mut TprHelper) -> *mut t_topology;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN9TprHelper10get_natomsEv"]
    pub fn TprHelper_get_natoms(this: *mut TprHelper) -> usize;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN9TprHelper12get_atom_xyzEm"]
    pub fn TprHelper_get_atom_xyz(this: *mut TprHelper, ind: usize) -> *mut f32;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN9TprHelper7get_boxEv"]
    pub fn TprHelper_get_box(this: *mut TprHelper) -> *mut f32;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN9TprHelper12get_atomnameEm"]
    pub fn TprHelper_get_atomname(this: *mut TprHelper, ind: usize) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN9TprHelperC1EPKc"]
    pub fn TprHelper_TprHelper(this: *mut TprHelper, fname: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN9TprHelperD1Ev"]
    pub fn TprHelper_TprHelper_destructor(this: *mut TprHelper);
}
impl TprHelper {
    #[inline]
    pub unsafe fn get_top(&mut self) -> *mut t_topology {
        TprHelper_get_top(self)
    }
    #[inline]
    pub unsafe fn get_natoms(&mut self) -> usize {
        TprHelper_get_natoms(self)
    }
    #[inline]
    pub unsafe fn get_atom_xyz(&mut self, ind: usize) -> *mut f32 {
        TprHelper_get_atom_xyz(self, ind)
    }
    #[inline]
    pub unsafe fn get_box(&mut self) -> *mut f32 {
        TprHelper_get_box(self)
    }
    #[inline]
    pub unsafe fn get_atomname(&mut self, ind: usize) -> *mut ::std::os::raw::c_char {
        TprHelper_get_atomname(self, ind)
    }
    #[inline]
    pub unsafe fn new(fname: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TprHelper_TprHelper(__bindgen_tmp.as_mut_ptr(), fname);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        TprHelper_TprHelper_destructor(self)
    }
}
