/* automatically generated by rust-bindgen 0.63.0 */

pub const vmdplugin_ABIVERSION: u32 = 18;
pub const VMDPLUGIN_THREADUNSAFE: u32 = 0;
pub const VMDPLUGIN_THREADSAFE: u32 = 1;
pub const VMDPLUGIN_SUCCESS: u32 = 0;
pub const VMDPLUGIN_ERROR: i32 = -1;
pub const MOLFILE_PLUGIN_TYPE: &[u8; 16usize] = b"mol file reader\0";
pub const MOLFILE_CONVERTER_PLUGIN_TYPE: &[u8; 19usize] = b"mol file converter\0";
pub const MOLFILE_SUCCESS: i32 = 0;
pub const MOLFILE_EOF: i32 = -1;
pub const MOLFILE_ERROR: i32 = -1;
pub const MOLFILE_NOSTRUCTUREDATA: i32 = -2;
pub const MOLFILE_NUMATOMS_UNKNOWN: i32 = -1;
pub const MOLFILE_NUMATOMS_NONE: u32 = 0;
pub const MOLFILE_BUFSIZ: u32 = 81;
pub const MOLFILE_BIGBUFSIZ: u32 = 4096;
pub const MOLFILE_MAXWAVEPERTS: u32 = 25;
pub const MOLFILE_DIRECTIO_MIN_BLOCK_SIZE: u32 = 4096;
pub const MOLFILE_DIRECTIO_MAX_BLOCK_SIZE: u32 = 4096;
pub const MOLFILE_NOOPTIONS: u32 = 0;
pub const MOLFILE_INSERTION: u32 = 1;
pub const MOLFILE_OCCUPANCY: u32 = 2;
pub const MOLFILE_BFACTOR: u32 = 4;
pub const MOLFILE_MASS: u32 = 8;
pub const MOLFILE_CHARGE: u32 = 16;
pub const MOLFILE_RADIUS: u32 = 32;
pub const MOLFILE_ALTLOC: u32 = 64;
pub const MOLFILE_ATOMICNUMBER: u32 = 128;
pub const MOLFILE_BONDSSPECIAL: u32 = 256;
pub const MOLFILE_BADOPTIONS: u32 = 4294967295;
pub const MOLFILE_QMTS_NOOPTIONS: u32 = 0;
pub const MOLFILE_QMTS_GRADIENT: u32 = 1;
pub const MOLFILE_QMTS_SCFITER: u32 = 2;
pub const MOLFILE_QMSTATUS_UNKNOWN: i32 = -1;
pub const MOLFILE_QMSTATUS_OPT_CONV: u32 = 0;
pub const MOLFILE_QMSTATUS_SCF_NOT_CONV: u32 = 1;
pub const MOLFILE_QMSTATUS_OPT_NOT_CONV: u32 = 2;
pub const MOLFILE_QMSTATUS_FILE_TRUNCATED: u32 = 3;
pub const MOLFILE_SCFTYPE_UNKNOWN: i32 = -1;
pub const MOLFILE_SCFTYPE_NONE: u32 = 0;
pub const MOLFILE_SCFTYPE_RHF: u32 = 1;
pub const MOLFILE_SCFTYPE_UHF: u32 = 2;
pub const MOLFILE_SCFTYPE_ROHF: u32 = 3;
pub const MOLFILE_SCFTYPE_GVB: u32 = 4;
pub const MOLFILE_SCFTYPE_MCSCF: u32 = 5;
pub const MOLFILE_SCFTYPE_FF: u32 = 6;
pub const MOLFILE_RUNTYPE_UNKNOWN: u32 = 0;
pub const MOLFILE_RUNTYPE_ENERGY: u32 = 1;
pub const MOLFILE_RUNTYPE_OPTIMIZE: u32 = 2;
pub const MOLFILE_RUNTYPE_SADPOINT: u32 = 3;
pub const MOLFILE_RUNTYPE_HESSIAN: u32 = 4;
pub const MOLFILE_RUNTYPE_SURFACE: u32 = 5;
pub const MOLFILE_RUNTYPE_GRADIENT: u32 = 6;
pub const MOLFILE_RUNTYPE_MEX: u32 = 7;
pub const MOLFILE_RUNTYPE_DYNAMICS: u32 = 8;
pub const MOLFILE_RUNTYPE_PROPERTIES: u32 = 9;
extern "C" {
    pub fn VMDPLUGIN_init() -> ::std::os::raw::c_int;
}
#[doc = " Typedef for generic plugin header, individual plugins can\n make their own structures as long as the header info remains\n the same as the generic plugin header, most easily done by\n using the vmdplugin_HEAD macro."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vmdplugin_t {
    pub abiversion: ::std::os::raw::c_int,
    pub type_: *const ::std::os::raw::c_char,
    pub name: *const ::std::os::raw::c_char,
    pub prettyname: *const ::std::os::raw::c_char,
    pub author: *const ::std::os::raw::c_char,
    pub majorv: ::std::os::raw::c_int,
    pub minorv: ::std::os::raw::c_int,
    pub is_reentrant: ::std::os::raw::c_int,
}
#[doc = " Function pointer typedef for register callback functions"]
pub type vmdplugin_register_cb = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut vmdplugin_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn VMDPLUGIN_register(
        arg1: *mut ::std::os::raw::c_void,
        arg2: vmdplugin_register_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VMDPLUGIN_register_tcl(
        arg1: *mut ::std::os::raw::c_void,
        tcl_interp: *mut ::std::os::raw::c_void,
        arg2: vmdplugin_register_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VMDPLUGIN_fini() -> ::std::os::raw::c_int;
}
#[doc = " File level comments, origin information, and annotations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct molfile_metadata_t {
    #[doc = "< database of origin, if any"]
    pub database: [::std::os::raw::c_char; 81usize],
    #[doc = "< database accession code, if any"]
    pub accession: [::std::os::raw::c_char; 81usize],
    #[doc = "< date/time stamp for this data"]
    pub date: [::std::os::raw::c_char; 81usize],
    #[doc = "< brief title for this data"]
    pub title: [::std::os::raw::c_char; 81usize],
    #[doc = "< length of remarks string"]
    pub remarklen: ::std::os::raw::c_int,
    #[doc = "< free-form remarks about data"]
    pub remarks: *mut ::std::os::raw::c_char,
}
#[doc = " Per-atom attributes and information."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Default)]
pub struct molfile_atom_t {
    #[doc = "< required atom name string"]
    pub name: [::std::os::raw::c_char; 16usize],
    #[doc = "< required atom type string"]
    pub type_: [::std::os::raw::c_char; 16usize],
    #[doc = "< required residue name string"]
    pub resname: [::std::os::raw::c_char; 8usize],
    #[doc = "< required integer residue ID"]
    pub resid: ::std::os::raw::c_int,
    #[doc = "< required segment name string, or \"\""]
    pub segid: [::std::os::raw::c_char; 8usize],
    #[doc = "< required chain name, or \"\""]
    pub chain: [::std::os::raw::c_char; 2usize],
    #[doc = "< optional PDB alternate location code"]
    pub altloc: [::std::os::raw::c_char; 2usize],
    #[doc = "< optional PDB insertion code"]
    pub insertion: [::std::os::raw::c_char; 2usize],
    #[doc = "< optional occupancy value"]
    pub occupancy: f32,
    #[doc = "< optional B-factor value"]
    pub bfactor: f32,
    #[doc = "< optional mass value"]
    pub mass: f32,
    #[doc = "< optional charge value"]
    pub charge: f32,
    #[doc = "< optional radius value"]
    pub radius: f32,
    #[doc = "< optional element atomic number"]
    pub atomicnumber: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct molfile_timestep_metadata {
    #[doc = "< total # timesteps; -1 if unknown"]
    pub count: ::std::os::raw::c_uint,
    pub avg_bytes_per_timestep: ::std::os::raw::c_uint,
    #[doc = "< if timesteps have velocities"]
    pub has_velocities: ::std::os::raw::c_int,
}
pub type molfile_timestep_metadata_t = molfile_timestep_metadata;
#[doc = " Per-timestep atom coordinates, velocities, time, energies\n and periodic cell info"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct molfile_timestep_t {
    #[doc = "< coordinates of all atoms, arranged xyzxyzxyz"]
    pub coords: *mut f32,
    #[doc = "< space for velocities of all atoms; same layout */\n/**< NULL unless has_velocities is set"]
    pub velocities: *mut f32,
    #[doc = " Unit cell specification of the form A, B, C, alpha, beta, gamma.\n notes: A, B, C are side lengths of the unit cell\n alpha = angle between b and c\n  beta = angle between a and c\n gamma = angle between a and b"]
    pub A: f32,
    #[doc = " Unit cell specification of the form A, B, C, alpha, beta, gamma.\n notes: A, B, C are side lengths of the unit cell\n alpha = angle between b and c\n  beta = angle between a and c\n gamma = angle between a and b"]
    pub B: f32,
    #[doc = " Unit cell specification of the form A, B, C, alpha, beta, gamma.\n notes: A, B, C are side lengths of the unit cell\n alpha = angle between b and c\n  beta = angle between a and c\n gamma = angle between a and b"]
    pub C: f32,
    #[doc = " Unit cell specification of the form A, B, C, alpha, beta, gamma.\n notes: A, B, C are side lengths of the unit cell\n alpha = angle between b and c\n  beta = angle between a and c\n gamma = angle between a and b"]
    pub alpha: f32,
    #[doc = " Unit cell specification of the form A, B, C, alpha, beta, gamma.\n notes: A, B, C are side lengths of the unit cell\n alpha = angle between b and c\n  beta = angle between a and c\n gamma = angle between a and b"]
    pub beta: f32,
    #[doc = " Unit cell specification of the form A, B, C, alpha, beta, gamma.\n notes: A, B, C are side lengths of the unit cell\n alpha = angle between b and c\n  beta = angle between a and c\n gamma = angle between a and b"]
    pub gamma: f32,
    #[doc = "< physical time point associated with this frame"]
    pub physical_time: f64,
}
#[doc = " Metadata for volumetric datasets, read initially and used for subsequent\n memory allocations and file loading."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct molfile_volumetric_t {
    #[doc = "< name of volumetric data set"]
    pub dataname: [::std::os::raw::c_char; 256usize],
    #[doc = "< origin: origin of volume (x=0, y=0, z=0 corner"]
    pub origin: [f32; 3usize],
    #[doc = "< direction (and length) for X axis"]
    pub xaxis: [f32; 3usize],
    #[doc = "< direction (and length) for Y axis"]
    pub yaxis: [f32; 3usize],
    #[doc = "< direction (and length) for Z axis"]
    pub zaxis: [f32; 3usize],
    #[doc = "< number of grid cells along the X axis"]
    pub xsize: ::std::os::raw::c_int,
    #[doc = "< number of grid cells along the Y axis"]
    pub ysize: ::std::os::raw::c_int,
    #[doc = "< number of grid cells along the Z axis"]
    pub zsize: ::std::os::raw::c_int,
    #[doc = "< flag indicating presence of scalar volume"]
    pub has_scalar: ::std::os::raw::c_int,
    #[doc = "< flag indicating presence of vector volume"]
    pub has_gradient: ::std::os::raw::c_int,
    #[doc = "< flag indicating presence of variance map"]
    pub has_variance: ::std::os::raw::c_int,
    #[doc = "< flag indicating presence of voxel color data"]
    pub has_color: ::std::os::raw::c_int,
}
#[doc = " Volumetric dataset read/write structure with both flag/parameter sets\n and VMD-allocated pointers for fields to be used by the plugin."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct molfile_volumetric_readwrite_t {
    #[doc = "< volumetric dataset index to load/save"]
    pub setidx: ::std::os::raw::c_int,
    #[doc = "< scalar density/potential field data"]
    pub scalar: *mut f32,
    #[doc = "< gradient vector field"]
    pub gradient: *mut f32,
    #[doc = "< variance map indicating signal/noise"]
    pub variance: *mut f32,
    #[doc = "< RGB floating point color texture map"]
    pub rgb3f: *mut f32,
    #[doc = "< RGB unsigned byte color texture map"]
    pub rgb3u: *mut ::std::os::raw::c_uchar,
}
#[doc = " Sizes of various QM-related, timestep independent data arrays\n which must be allocated by the caller (VMD) so that the plugin\n can fill in the arrays with data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct molfile_qm_metadata_t {
    #[doc = "< number of imaginary modes"]
    pub nimag: ::std::os::raw::c_int,
    #[doc = "< number internal coordinates"]
    pub nintcoords: ::std::os::raw::c_int,
    #[doc = "< number cartesian coordinates"]
    pub ncart: ::std::os::raw::c_int,
    #[doc = "< number of uncontracted basis functions in basis array"]
    pub num_basis_funcs: ::std::os::raw::c_int,
    #[doc = "< number of atoms in basis set"]
    pub num_basis_atoms: ::std::os::raw::c_int,
    #[doc = "< total number of atomic shells"]
    pub num_shells: ::std::os::raw::c_int,
    #[doc = "< size of the wavefunction\n   i.e. size of secular eq. or\n   # of cartesian contracted\n   gaussian basis functions"]
    pub wavef_size: ::std::os::raw::c_int,
    pub have_sysinfo: ::std::os::raw::c_int,
    #[doc = "< hessian in cartesian coords available"]
    pub have_carthessian: ::std::os::raw::c_int,
    #[doc = "< hessian in internal coords available"]
    pub have_inthessian: ::std::os::raw::c_int,
    #[doc = "< normal modes available"]
    pub have_normalmodes: ::std::os::raw::c_int,
}
#[doc = " QM run info. Parameters that stay unchanged during a single file."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct molfile_qm_sysinfo_t {
    #[doc = "< number of processors used."]
    pub nproc: ::std::os::raw::c_int,
    #[doc = "< amount of memory used in Mbyte."]
    pub memory: ::std::os::raw::c_int,
    #[doc = "< flag indicating the calculation method."]
    pub runtype: ::std::os::raw::c_int,
    #[doc = "< SCF type: RHF, UHF, ROHF, GVB or MCSCF wfn."]
    pub scftype: ::std::os::raw::c_int,
    #[doc = "< indicates wether SCF and geometry optimization\n   have converged properly."]
    pub status: ::std::os::raw::c_int,
    #[doc = "< number of electrons.    XXX: can be fractional in some DFT codes"]
    pub num_electrons: ::std::os::raw::c_int,
    #[doc = "< total charge of system. XXX: can be fractional in some DFT codes"]
    pub totalcharge: ::std::os::raw::c_int,
    #[doc = "< number of occupied alpha orbitals"]
    pub num_occupied_A: ::std::os::raw::c_int,
    #[doc = "< number of occupied beta orbitals"]
    pub num_occupied_B: ::std::os::raw::c_int,
    #[doc = "< array(natom) containing the nuclear charge of atom i"]
    pub nuc_charge: *mut f64,
    #[doc = "< basis name as \"nice\" string."]
    pub basis_string: [::std::os::raw::c_char; 81usize],
    #[doc = "< title of run."]
    pub runtitle: [::std::os::raw::c_char; 4096usize],
    #[doc = "< type of provided geometry,   XXX: remove?\n e.g. UNIQUE, ZMT, CART, ..."]
    pub geometry: [::std::os::raw::c_char; 81usize],
    #[doc = "< QM code version information."]
    pub version_string: [::std::os::raw::c_char; 81usize],
}
#[doc = " Data for QM basis set"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct molfile_qm_basis_t {
    #[doc = "< number of shells per atom"]
    pub num_shells_per_atom: *mut ::std::os::raw::c_int,
    #[doc = "< number of shell primitives shell"]
    pub num_prim_per_shell: *mut ::std::os::raw::c_int,
    #[doc = "< contraction coeffients and exponents for\n   the basis functions in the form\n   {exp(1), c-coeff(1), exp(2), c-coeff(2), ...};\n   array size = 2*num_basis_funcs\n   The basis must NOT be normalized."]
    pub basis: *mut f32,
    #[doc = "< atomic numbers (chem. element) of atoms in basis set"]
    pub atomic_number: *mut ::std::os::raw::c_int,
    #[doc = "< 3 ints per wave function coefficient do describe the\n   cartesian components of the angular momentum.\n   E.g. S={0 0 0}, Px={1 0 0}, Dxy={1 1 0}, or Fyyz={0 2 1}."]
    pub angular_momentum: *mut ::std::os::raw::c_int,
    #[doc = "< type for each shell in basis"]
    pub shell_types: *mut ::std::os::raw::c_int,
}
#[doc = " Data from QM Hessian/normal mode runs\n\n A noteworthy comment from one of Axel's emails:\n The molfile_qm_hessian_t, I'd rename to molfile_hessian_t (one\n can do vibrational analysis without QM) and would make this a\n completely separate entity. This could then be also used to\n read in data from, say, principal component analysis or normal\n mode analysis and VMD could contain code to either project a\n trajectory on the contained eigenvectors or animate them and\n so on. There is a bunch of possible applications..."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct molfile_qm_hessian_t {
    #[doc = "< hessian matrix in cartesian coordinates (ncart)*(ncart)\n   as a single array of doubles (row(1), ...,row(natoms))"]
    pub carthessian: *mut f64,
    #[doc = "< list(nimag) of imaginary modes"]
    pub imag_modes: *mut ::std::os::raw::c_int,
    #[doc = "< hessian matrix in internal coordinates\n   (nintcoords*nintcoords) as a single array of\n   doubles (row(1), ...,row(nintcoords))"]
    pub inthessian: *mut f64,
    #[doc = "< array(ncart) of wavenumbers of normal modes"]
    pub wavenumbers: *mut f32,
    #[doc = "< array(ncart) of intensities of normal modes"]
    pub intensities: *mut f32,
    #[doc = "< matrix(ncart*ncart) of normal modes"]
    pub normalmodes: *mut f32,
}
#[doc = " QM related information that is timestep independent"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct molfile_qm_t {
    pub run: molfile_qm_sysinfo_t,
    pub basis: molfile_qm_basis_t,
    pub hess: molfile_qm_hessian_t,
}
pub const molfile_qm_wavefunc_type_MOLFILE_WAVE_CANON: molfile_qm_wavefunc_type = 0;
pub const molfile_qm_wavefunc_type_MOLFILE_WAVE_GEMINAL: molfile_qm_wavefunc_type = 1;
pub const molfile_qm_wavefunc_type_MOLFILE_WAVE_MCSCFNAT: molfile_qm_wavefunc_type = 2;
pub const molfile_qm_wavefunc_type_MOLFILE_WAVE_MCSCFOPT: molfile_qm_wavefunc_type = 3;
pub const molfile_qm_wavefunc_type_MOLFILE_WAVE_CINATUR: molfile_qm_wavefunc_type = 4;
pub const molfile_qm_wavefunc_type_MOLFILE_WAVE_PIPEK: molfile_qm_wavefunc_type = 5;
pub const molfile_qm_wavefunc_type_MOLFILE_WAVE_BOYS: molfile_qm_wavefunc_type = 6;
pub const molfile_qm_wavefunc_type_MOLFILE_WAVE_RUEDEN: molfile_qm_wavefunc_type = 7;
pub const molfile_qm_wavefunc_type_MOLFILE_WAVE_NAO: molfile_qm_wavefunc_type = 8;
pub const molfile_qm_wavefunc_type_MOLFILE_WAVE_PNAO: molfile_qm_wavefunc_type = 9;
pub const molfile_qm_wavefunc_type_MOLFILE_WAVE_NHO: molfile_qm_wavefunc_type = 10;
pub const molfile_qm_wavefunc_type_MOLFILE_WAVE_PNHO: molfile_qm_wavefunc_type = 11;
pub const molfile_qm_wavefunc_type_MOLFILE_WAVE_NBO: molfile_qm_wavefunc_type = 12;
pub const molfile_qm_wavefunc_type_MOLFILE_WAVE_PNBO: molfile_qm_wavefunc_type = 13;
pub const molfile_qm_wavefunc_type_MOLFILE_WAVE_PNLMO: molfile_qm_wavefunc_type = 14;
pub const molfile_qm_wavefunc_type_MOLFILE_WAVE_NLMO: molfile_qm_wavefunc_type = 15;
pub const molfile_qm_wavefunc_type_MOLFILE_WAVE_MOAO: molfile_qm_wavefunc_type = 16;
pub const molfile_qm_wavefunc_type_MOLFILE_WAVE_NATO: molfile_qm_wavefunc_type = 17;
pub const molfile_qm_wavefunc_type_MOLFILE_WAVE_UNKNOWN: molfile_qm_wavefunc_type = 18;
#[doc = "  Enumeration of all of the wavefunction types that can be read\n  from QM file reader plugins.\n\n  CANON    = canonical (i.e diagonalized) wavefunction\n  GEMINAL  = GVB-ROHF geminal pairs\n  MCSCFNAT = Multi-Configuration SCF natural orbitals\n  MCSCFOPT = Multi-Configuration SCF optimized orbitals\n  CINATUR  = Configuration-Interaction natural orbitals\n  BOYS     = Boys localization\n  RUEDEN   = Ruedenberg localization\n  PIPEK    = Pipek-Mezey population localization\n\n  NBO related localizations:\n  --------------------------\n  NAO      = Natural Atomic Orbitals\n  PNAO     = pre-orthogonal NAOs\n  NBO      = Natural Bond Orbitals\n  PNBO     = pre-orthogonal NBOs\n  NHO      = Natural Hybrid Orbitals\n  PNHO     = pre-orthogonal NHOs\n  NLMO     = Natural Localized Molecular Orbitals\n  PNLMO    = pre-orthogonal NLMOs\n\n  UNKNOWN  = Use this for any type not listed here\n             You can use the string field for description"]
pub type molfile_qm_wavefunc_type = ::std::os::raw::c_uint;
pub const molfile_qm_charge_type_MOLFILE_QMCHARGE_UNKNOWN: molfile_qm_charge_type = 0;
pub const molfile_qm_charge_type_MOLFILE_QMCHARGE_MULLIKEN: molfile_qm_charge_type = 1;
pub const molfile_qm_charge_type_MOLFILE_QMCHARGE_LOWDIN: molfile_qm_charge_type = 2;
pub const molfile_qm_charge_type_MOLFILE_QMCHARGE_ESP: molfile_qm_charge_type = 3;
pub const molfile_qm_charge_type_MOLFILE_QMCHARGE_NPA: molfile_qm_charge_type = 4;
#[doc = "  Enumeration of all of the supported QM related charge\n  types"]
pub type molfile_qm_charge_type = ::std::os::raw::c_uint;
#[doc = " Sizes of various QM-related, per-timestep data arrays\n which must be allocated by the caller (VMD) so that the plugin\n can fill in the arrays with data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct molfile_qm_timestep_metadata {
    #[doc = "< total # timesteps; -1 if unknown"]
    pub count: ::std::os::raw::c_uint,
    #[doc = "< bytes per timestep"]
    pub avg_bytes_per_timestep: ::std::os::raw::c_uint,
    #[doc = "< if timestep contains gradient"]
    pub has_gradient: ::std::os::raw::c_int,
    #[doc = "< # scf iterations for this ts"]
    pub num_scfiter: ::std::os::raw::c_int,
    #[doc = "< # orbitals for each wavefunction"]
    pub num_orbitals_per_wavef: [::std::os::raw::c_int; 25usize],
    #[doc = "< orbital energy flags"]
    pub has_orben_per_wavef: [::std::os::raw::c_int; 25usize],
    #[doc = "< orbital occupancy flags"]
    pub has_occup_per_wavef: [::std::os::raw::c_int; 25usize],
    #[doc = "< # wavefunctions in this ts"]
    pub num_wavef: ::std::os::raw::c_int,
    #[doc = "< size of one wavefunction\n   (# of gaussian basis fctns)"]
    pub wavef_size: ::std::os::raw::c_int,
    #[doc = "< # of charge values per atom"]
    pub num_charge_sets: ::std::os::raw::c_int,
}
#[doc = " Sizes of various QM-related, per-timestep data arrays\n which must be allocated by the caller (VMD) so that the plugin\n can fill in the arrays with data."]
pub type molfile_qm_timestep_metadata_t = molfile_qm_timestep_metadata;
#[doc = " QM wavefunction"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct molfile_qm_wavefunction_t {
    #[doc = "< MOLFILE_WAVE_CANON, MOLFILE_WAVE_MCSCFNAT, ..."]
    pub type_: ::std::os::raw::c_int,
    #[doc = "< 1 for alpha, -1 for beta"]
    pub spin: ::std::os::raw::c_int,
    #[doc = "< 0 for ground state, 1,2,3,... for excited states"]
    pub excitation: ::std::os::raw::c_int,
    #[doc = "< spin multiplicity of the state, zero if unknown"]
    pub multiplicity: ::std::os::raw::c_int,
    #[doc = "< string for additional type info"]
    pub info: [::std::os::raw::c_char; 81usize],
    #[doc = "< energy of the electronic state.\n   i.e. HF-SCF energy, CI state energy,\n   MCSCF energy, etc."]
    pub energy: f64,
    #[doc = "< expansion coefficients for wavefunction in the\n   form {orbital1(c1),orbital1(c2),.....,orbitalM(cN)}"]
    pub wave_coeffs: *mut f32,
    #[doc = "< list of orbital energies for wavefunction"]
    pub orbital_energies: *mut f32,
    #[doc = "< orbital occupancies"]
    pub occupancies: *mut f32,
    #[doc = "< orbital ID numbers; If NULL then VMD will\n   assume 1,2,3,...num_orbs."]
    pub orbital_ids: *mut ::std::os::raw::c_int,
}
#[doc = " QM per trajectory timestep info\n Note that each timestep can contain multiple wavefunctions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct molfile_qm_timestep_t {
    #[doc = "< array of wavefunction objects"]
    pub wave: *mut molfile_qm_wavefunction_t,
    #[doc = "< force on each atom (=gradient of energy)"]
    pub gradient: *mut f32,
    #[doc = "< energies from the SCF cycles"]
    pub scfenergies: *mut f64,
    #[doc = "< per-atom charges"]
    pub charges: *mut f64,
    #[doc = "< type of each charge set"]
    pub charge_types: *mut ::std::os::raw::c_int,
}
pub const molfile_graphics_type_MOLFILE_POINT: molfile_graphics_type = 0;
pub const molfile_graphics_type_MOLFILE_TRIANGLE: molfile_graphics_type = 1;
pub const molfile_graphics_type_MOLFILE_TRINORM: molfile_graphics_type = 2;
pub const molfile_graphics_type_MOLFILE_NORMS: molfile_graphics_type = 3;
pub const molfile_graphics_type_MOLFILE_LINE: molfile_graphics_type = 4;
pub const molfile_graphics_type_MOLFILE_CYLINDER: molfile_graphics_type = 5;
pub const molfile_graphics_type_MOLFILE_CAPCYL: molfile_graphics_type = 6;
pub const molfile_graphics_type_MOLFILE_CONE: molfile_graphics_type = 7;
pub const molfile_graphics_type_MOLFILE_SPHERE: molfile_graphics_type = 8;
pub const molfile_graphics_type_MOLFILE_TEXT: molfile_graphics_type = 9;
pub const molfile_graphics_type_MOLFILE_COLOR: molfile_graphics_type = 10;
pub const molfile_graphics_type_MOLFILE_TRICOLOR: molfile_graphics_type = 11;
#[doc = "  Enumeration of all of the supported graphics objects that can be read\n  from graphics file reader plugins."]
pub type molfile_graphics_type = ::std::os::raw::c_uint;
#[doc = "  Individual graphics object/element data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct molfile_graphics_t {
    pub type_: ::std::os::raw::c_int,
    pub style: ::std::os::raw::c_int,
    pub size: f32,
    pub data: [f32; 9usize],
}
#[doc = " Main file reader API.  Any function in this struct may be NULL\n if not implemented by the plugin; the application checks this to determine\n what functionality is present in the plugin."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct molfile_plugin_t {
    pub abiversion: ::std::os::raw::c_int,
    pub type_: *const ::std::os::raw::c_char,
    pub name: *const ::std::os::raw::c_char,
    pub prettyname: *const ::std::os::raw::c_char,
    pub author: *const ::std::os::raw::c_char,
    pub majorv: ::std::os::raw::c_int,
    pub minorv: ::std::os::raw::c_int,
    pub is_reentrant: ::std::os::raw::c_int,
    #[doc = " Filename extension for this file type.  May be NULL if no filename\n extension exists and/or is known.  For file types that match several\n common extensions, list them in a comma separated list such as:\n  \"pdb,ent,foo,bar,baz,ban\"\n The comma separated list will be expanded when filename extension matching\n is performed.  If multiple plugins solicit the same filename extensions,\n the one that lists the extension earliest in its list is selected. In the\n case of a \"tie\", the first one tried/checked \"wins\"."]
    pub filename_extension: *const ::std::os::raw::c_char,
    #[doc = " Try to open the file for reading.  Return an opaque handle, or NULL on\n failure. Set the number of atoms; if the number of atoms cannot be\n determined, set natoms to MOLFILE_NUMATOMS_UNKNOWN.\n Filetype should be the name under which this plugin was registered;\n this is provided so that plugins can provide the same function pointer\n to handle multiple file types."]
    pub open_file_read: ::std::option::Option<
        unsafe extern "C" fn(
            filepath: *const ::std::os::raw::c_char,
            filetype: *const ::std::os::raw::c_char,
            natoms: *mut ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Read molecular structure from the given file handle.  atoms is allocated\n by the caller and points to space for natoms.\n On success, place atom information in the passed-in pointer.\n optflags specifies which optional fields in the atoms will be set by\n the plugin."]
    pub read_structure: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            optflags: *mut ::std::os::raw::c_int,
            atoms: *mut molfile_atom_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Read bond information for the molecule.  On success the arrays from\n and to should point to the (one-based) indices of bonded atoms.\n Each unique bond should be specified only once, so file formats that list\n bonds twice will need post-processing before the results are returned to\n the caller.\n If the plugin provides bond information, but the file loaded doesn't\n actually contain any bond info, the nbonds parameter should be\n set to 0 and from/to should be set to NULL to indicate that no bond\n information was actually present, and automatic bond search should be\n performed.\n\n If the plugin provides bond order information, the bondorder array\n will contain the bond order for each from/to pair.  If not, the bondorder\n pointer should be set to NULL, in which case the caller will provide a\n default bond order value of 1.0.\n\n If the plugin provides bond type information, the bondtype array\n will contain the bond type index for each from/to pair. These numbers\n are consecutive integers starting from 0.\n the bondtypenames list, contains the corresponding names, if available,\n as a NULL string terminated list. nbondtypes is provided for convenience\n and consistency checking.\n\n These arrays must be freed by the plugin in the close_file_read function.\n This function can be called only after read_structure().\n Return MOLFILE_SUCCESS if no errors occur."]
    pub read_bonds: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            nbonds: *mut ::std::os::raw::c_int,
            from: *mut *mut ::std::os::raw::c_int,
            to: *mut *mut ::std::os::raw::c_int,
            bondorder: *mut *mut f32,
            bondtype: *mut *mut ::std::os::raw::c_int,
            nbondtypes: *mut ::std::os::raw::c_int,
            bondtypename: *mut *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " XXX this function will be augmented and possibly superceded by a\n     new QM-capable version named read_timestep(), when finished.\n\n Read the next timestep from the file.  Return MOLFILE_SUCCESS, or\n MOLFILE_EOF on EOF.  If the molfile_timestep_t argument is NULL, then\n the frame should be skipped.  Otherwise, the application must prepare\n molfile_timestep_t by allocating space in coords for the corresponding\n number of coordinates.\n The natoms parameter exists because some coordinate file formats\n (like CRD) cannot determine for themselves how many atoms are in a\n timestep; the app must therefore obtain this information elsewhere\n and provide it to the plugin."]
    pub read_next_timestep: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            natoms: ::std::os::raw::c_int,
            arg2: *mut molfile_timestep_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Close the file and release all data.  The handle cannot be reused."]
    pub close_file_read:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    #[doc = " Open a coordinate file for writing using the given header information.\n Return an opaque handle, or NULL on failure.  The application must\n specify the number of atoms to be written.\n filetype should be the name under which this plugin was registered."]
    pub open_file_write: ::std::option::Option<
        unsafe extern "C" fn(
            filepath: *const ::std::os::raw::c_char,
            filetype: *const ::std::os::raw::c_char,
            natoms: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Write structure information.  Return success."]
    pub write_structure: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            optflags: ::std::os::raw::c_int,
            atoms: *const molfile_atom_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Write a timestep to the coordinate file.  Return MOLFILE_SUCCESS if no\n errors occur.  If the file contains structure information in each\n timestep (like a multi-entry PDB), it will have to cache the information\n from the initial calls from write_structure."]
    pub write_timestep: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const molfile_timestep_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Close the file and release all data.  The handle cannot be reused."]
    pub close_file_write:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    #[doc = " Retrieve metadata pertaining to volumetric datasets in this file.\n Set nsets to the number of volumetric data sets, and set *metadata\n to point to an array of molfile_volumetric_t.  The array is owned by\n the plugin and should be freed by close_file_read().  The application\n may call this function any number of times."]
    pub read_volumetric_metadata: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            nsets: *mut ::std::os::raw::c_int,
            metadata: *mut *mut molfile_volumetric_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Read the specified volumetric data set into the space pointed to by\n datablock.  The set is specified with a zero-based index.  The space\n allocated for the datablock must be equal to\n xsize * ysize * zsize.  No space will be allocated for colorblock\n unless has_color is nonzero; in that case, colorblock should be\n filled in with three RGB floats per datapoint."]
    pub read_volumetric_data: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            set: ::std::os::raw::c_int,
            datablock: *mut f32,
            colorblock: *mut f32,
        ) -> ::std::os::raw::c_int,
    >,
    pub read_volumetric_data_ex: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            v: *mut molfile_volumetric_readwrite_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Read raw graphics data stored in this file.   Return the number of data\n elements and the data itself as an array of molfile_graphics_t in the\n pointer provided by the application.  The plugin is responsible for\n freeing the data when the file is closed."]
    pub read_rawgraphics: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            nelem: *mut ::std::os::raw::c_int,
            data: *mut *const molfile_graphics_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Read molecule metadata such as what database (if any) this file/data\n came from, what the accession code for the database is, textual remarks\n and other notes pertaining to the contained structure/trajectory/volume\n and anything else that's informative at the whole file level."]
    pub read_molecule_metadata: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            metadata: *mut *mut molfile_metadata_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Write bond information for the molecule.  The arrays from\n and to point to the (one-based) indices of bonded atoms.\n Each unique bond will be specified only once by the caller.\n File formats that list bonds twice will need to emit both the\n from/to and to/from versions of each.\n This function must be called before write_structure().\n\n Like the read_bonds() routine, the bondorder pointer is set to NULL\n if the caller doesn't have such information, in which case the\n plugin should assume a bond order of 1.0 if the file format requires\n bond order information.\n\n Support for bond types follows the bondorder rules. bondtype is\n an integer array of the size nbonds that contains the bond type\n index (consecutive integers starting from 0) and bondtypenames\n contain the corresponding strings, in case the naming/numbering\n scheme is different from the index numbers.\n if the pointers are set to NULL, then this information is not available.\n bondtypenames can only be used of bondtypes is also given.\n Return MOLFILE_SUCCESS if no errors occur."]
    pub write_bonds: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            nbonds: ::std::os::raw::c_int,
            from: *mut ::std::os::raw::c_int,
            to: *mut ::std::os::raw::c_int,
            bondorder: *mut f32,
            bondtype: *mut ::std::os::raw::c_int,
            nbondtypes: ::std::os::raw::c_int,
            bondtypename: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Write the specified volumetric data set into the space pointed to by\n datablock.  The * allocated for the datablock must be equal to\n xsize * ysize * zsize.  No space will be allocated for colorblock\n unless has_color is nonzero; in that case, colorblock should be\n filled in with three RGB floats per datapoint."]
    pub write_volumetric_data: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            metadata: *mut molfile_volumetric_t,
            datablock: *mut f32,
            colorblock: *mut f32,
        ) -> ::std::os::raw::c_int,
    >,
    pub write_volumetric_data_ex: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            metadata: *mut molfile_volumetric_t,
            v: *mut molfile_volumetric_readwrite_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Read in Angles, Dihedrals, Impropers, and Cross Terms and optionally types.\n (Cross terms pertain to the CHARMM/NAMD CMAP feature)"]
    pub read_angles: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            numangles: *mut ::std::os::raw::c_int,
            angles: *mut *mut ::std::os::raw::c_int,
            angletypes: *mut *mut ::std::os::raw::c_int,
            numangletypes: *mut ::std::os::raw::c_int,
            angletypenames: *mut *mut *mut ::std::os::raw::c_char,
            numdihedrals: *mut ::std::os::raw::c_int,
            dihedrals: *mut *mut ::std::os::raw::c_int,
            dihedraltypes: *mut *mut ::std::os::raw::c_int,
            numdihedraltypes: *mut ::std::os::raw::c_int,
            dihedraltypenames: *mut *mut *mut ::std::os::raw::c_char,
            numimpropers: *mut ::std::os::raw::c_int,
            impropers: *mut *mut ::std::os::raw::c_int,
            impropertypes: *mut *mut ::std::os::raw::c_int,
            numimpropertypes: *mut ::std::os::raw::c_int,
            impropertypenames: *mut *mut *mut ::std::os::raw::c_char,
            numcterms: *mut ::std::os::raw::c_int,
            cterms: *mut *mut ::std::os::raw::c_int,
            ctermcols: *mut ::std::os::raw::c_int,
            ctermrows: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Write out Angles, Dihedrals, Impropers, and Cross Terms\n (Cross terms pertain to the CHARMM/NAMD CMAP feature)"]
    pub write_angles: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            numangles: ::std::os::raw::c_int,
            angles: *const ::std::os::raw::c_int,
            angletypes: *const ::std::os::raw::c_int,
            numangletypes: ::std::os::raw::c_int,
            angletypenames: *mut *const ::std::os::raw::c_char,
            numdihedrals: ::std::os::raw::c_int,
            dihedrals: *const ::std::os::raw::c_int,
            dihedraltypes: *const ::std::os::raw::c_int,
            numdihedraltypes: ::std::os::raw::c_int,
            dihedraltypenames: *mut *const ::std::os::raw::c_char,
            numimpropers: ::std::os::raw::c_int,
            impropers: *const ::std::os::raw::c_int,
            impropertypes: *const ::std::os::raw::c_int,
            numimpropertypes: ::std::os::raw::c_int,
            impropertypenames: *mut *const ::std::os::raw::c_char,
            numcterms: ::std::os::raw::c_int,
            cterms: *const ::std::os::raw::c_int,
            ctermcols: ::std::os::raw::c_int,
            ctermrows: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Retrieve metadata pertaining to timestep independent\n QM datasets in this file.\n\n The metadata are the sizes of the QM related data structure\n arrays that will be populated by the plugin when\n read_qm_rundata() is called. Since the allocation of these\n arrays is done by VMD rather than the plugin, VMD needs to\n know the sizes beforehand. Consequently read_qm_metadata()\n has to be called before read_qm_rundata()."]
    pub read_qm_metadata: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            metadata: *mut molfile_qm_metadata_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Read timestep independent QM data.\n\n Typical data that are defined only once per trajectory are\n general info about the calculation (such as the used method),\n the basis set and normal modes.\n The data structures to be populated must have been allocated\n before by VMD according to sizes obtained through\n read_qm_metadata()."]
    pub read_qm_rundata: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            qmdata: *mut molfile_qm_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub read_timestep_pagealign_size: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            pagealignsize: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Read the next timestep from the file.  Return MOLFILE_SUCCESS, or\n MOLFILE_EOF on EOF.  If the molfile_timestep_t or molfile_qm_metadata_t\n arguments are NULL, then the coordinate or qm data should be skipped.\n Otherwise, the application must prepare molfile_timestep_t and\n molfile_qm_timestep_t by allocating space for the corresponding\n number of coordinates, orbital wavefunction coefficients, etc.\n Since it is common for users to want to load only the final timestep\n data from a QM run, the application may provide any combination of\n valid, or NULL pointers for the molfile_timestep_t and\n molfile_qm_timestep_t parameters, depending on what information the\n user is interested in.\n The natoms and qm metadata parameters exist because some file formats\n cannot determine for themselves how many atoms etc are in a\n timestep; the app must therefore obtain this information elsewhere\n and provide it to the plugin."]
    pub read_timestep: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            natoms: ::std::os::raw::c_int,
            arg2: *mut molfile_timestep_t,
            arg3: *mut molfile_qm_metadata_t,
            arg4: *mut molfile_qm_timestep_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub read_timestep_metadata: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut molfile_timestep_metadata_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub read_qm_timestep_metadata: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut molfile_qm_timestep_metadata_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = "  Console output, READ-ONLY function pointer.\n  Function pointer that plugins can use for printing to the host\n  application's text console.  This provides a clean way for plugins\n  to send message strings back to the calling application, giving the\n  caller the ability to prioritize, buffer, and redirect console messages\n  to an appropriate output channel, window, etc.  This enables the use of\n  graphical consoles like TkCon without losing console output from plugins.\n  If the function pointer is NULL, no console output service is provided\n  by the calling application, and the output should default to stdout\n  stream.  If the function pointer is non-NULL, all output will be\n  subsequently dealt with by the calling application.\n\n  XXX this should really be put into a separate block of\n      application-provided read-only function pointers for any\n      application-provided services"]
    pub cons_fputs: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
}
extern "C" {
    pub fn pdb_get_plugin_ptr() -> *mut molfile_plugin_t;
}
extern "C" {
    pub fn xyz_get_plugin_ptr() -> *mut molfile_plugin_t;
}
extern "C" {
    pub fn dcd_get_plugin_ptr() -> *mut molfile_plugin_t;
}
